{"version":3,"file":"timeline.min.js","sources":["../node_modules/preact/dist/preact.mjs","../node_modules/keycon/dist/keycon.esm.js","../node_modules/@daybrush/drag/dist/drag.esm.js","../node_modules/@egjs/hammerjs/dist/hammer.esm.js","../src/Timeline.tsx"],"sourcesContent":["var VNode = function VNode() {};\n\nvar options = {};\n\nvar stack = [];\n\nvar EMPTY_CHILDREN = [];\n\nfunction h(nodeName, attributes) {\n\tvar children = EMPTY_CHILDREN,\n\t    lastSimple,\n\t    child,\n\t    simple,\n\t    i;\n\tfor (i = arguments.length; i-- > 2;) {\n\t\tstack.push(arguments[i]);\n\t}\n\tif (attributes && attributes.children != null) {\n\t\tif (!stack.length) stack.push(attributes.children);\n\t\tdelete attributes.children;\n\t}\n\twhile (stack.length) {\n\t\tif ((child = stack.pop()) && child.pop !== undefined) {\n\t\t\tfor (i = child.length; i--;) {\n\t\t\t\tstack.push(child[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof child === 'boolean') child = null;\n\n\t\t\tif (simple = typeof nodeName !== 'function') {\n\t\t\t\tif (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;\n\t\t\t}\n\n\t\t\tif (simple && lastSimple) {\n\t\t\t\tchildren[children.length - 1] += child;\n\t\t\t} else if (children === EMPTY_CHILDREN) {\n\t\t\t\tchildren = [child];\n\t\t\t} else {\n\t\t\t\tchildren.push(child);\n\t\t\t}\n\n\t\t\tlastSimple = simple;\n\t\t}\n\t}\n\n\tvar p = new VNode();\n\tp.nodeName = nodeName;\n\tp.children = children;\n\tp.attributes = attributes == null ? undefined : attributes;\n\tp.key = attributes == null ? undefined : attributes.key;\n\n\tif (options.vnode !== undefined) options.vnode(p);\n\n\treturn p;\n}\n\nfunction extend(obj, props) {\n  for (var i in props) {\n    obj[i] = props[i];\n  }return obj;\n}\n\nfunction applyRef(ref, value) {\n  if (ref != null) {\n    if (typeof ref == 'function') ref(value);else ref.current = value;\n  }\n}\n\nvar defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;\n\nfunction cloneElement(vnode, props) {\n  return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n}\n\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\nvar items = [];\n\nfunction enqueueRender(component) {\n\tif (!component._dirty && (component._dirty = true) && items.push(component) == 1) {\n\t\t(options.debounceRendering || defer)(rerender);\n\t}\n}\n\nfunction rerender() {\n\tvar p;\n\twhile (p = items.pop()) {\n\t\tif (p._dirty) renderComponent(p);\n\t}\n}\n\nfunction isSameNodeType(node, vnode, hydrating) {\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\t\treturn node.splitText !== undefined;\n\t}\n\tif (typeof vnode.nodeName === 'string') {\n\t\treturn !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n\t}\n\treturn hydrating || node._componentConstructor === vnode.nodeName;\n}\n\nfunction isNamedNode(node, nodeName) {\n\treturn node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();\n}\n\nfunction getNodeProps(vnode) {\n\tvar props = extend({}, vnode.attributes);\n\tprops.children = vnode.children;\n\n\tvar defaultProps = vnode.nodeName.defaultProps;\n\tif (defaultProps !== undefined) {\n\t\tfor (var i in defaultProps) {\n\t\t\tif (props[i] === undefined) {\n\t\t\t\tprops[i] = defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn props;\n}\n\nfunction createNode(nodeName, isSvg) {\n\tvar node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);\n\tnode.normalizedNodeName = nodeName;\n\treturn node;\n}\n\nfunction removeNode(node) {\n\tvar parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nfunction setAccessor(node, name, old, value, isSvg) {\n\tif (name === 'className') name = 'class';\n\n\tif (name === 'key') {} else if (name === 'ref') {\n\t\tapplyRef(old, null);\n\t\tapplyRef(value, node);\n\t} else if (name === 'class' && !isSvg) {\n\t\tnode.className = value || '';\n\t} else if (name === 'style') {\n\t\tif (!value || typeof value === 'string' || typeof old === 'string') {\n\t\t\tnode.style.cssText = value || '';\n\t\t}\n\t\tif (value && typeof value === 'object') {\n\t\t\tif (typeof old !== 'string') {\n\t\t\t\tfor (var i in old) {\n\t\t\t\t\tif (!(i in value)) node.style[i] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i in value) {\n\t\t\t\tnode.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];\n\t\t\t}\n\t\t}\n\t} else if (name === 'dangerouslySetInnerHTML') {\n\t\tif (value) node.innerHTML = value.__html || '';\n\t} else if (name[0] == 'o' && name[1] == 'n') {\n\t\tvar useCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tname = name.toLowerCase().substring(2);\n\t\tif (value) {\n\t\t\tif (!old) node.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tnode.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\t(node._listeners || (node._listeners = {}))[name] = value;\n\t} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {\n\t\ttry {\n\t\t\tnode[name] = value == null ? '' : value;\n\t\t} catch (e) {}\n\t\tif ((value == null || value === false) && name != 'spellcheck') node.removeAttribute(name);\n\t} else {\n\t\tvar ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));\n\n\t\tif (value == null || value === false) {\n\t\t\tif (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);\n\t\t} else if (typeof value !== 'function') {\n\t\t\tif (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);\n\t\t}\n\t}\n}\n\nfunction eventProxy(e) {\n\treturn this._listeners[e.type](options.event && options.event(e) || e);\n}\n\nvar mounts = [];\n\nvar diffLevel = 0;\n\nvar isSvgMode = false;\n\nvar hydrating = false;\n\nfunction flushMounts() {\n\tvar c;\n\twhile (c = mounts.shift()) {\n\t\tif (options.afterMount) options.afterMount(c);\n\t\tif (c.componentDidMount) c.componentDidMount();\n\t}\n}\n\nfunction diff(dom, vnode, context, mountAll, parent, componentRoot) {\n\tif (!diffLevel++) {\n\t\tisSvgMode = parent != null && parent.ownerSVGElement !== undefined;\n\n\t\thydrating = dom != null && !('__preactattr_' in dom);\n\t}\n\n\tvar ret = idiff(dom, vnode, context, mountAll, componentRoot);\n\n\tif (parent && ret.parentNode !== parent) parent.appendChild(ret);\n\n\tif (! --diffLevel) {\n\t\thydrating = false;\n\n\t\tif (!componentRoot) flushMounts();\n\t}\n\n\treturn ret;\n}\n\nfunction idiff(dom, vnode, context, mountAll, componentRoot) {\n\tvar out = dom,\n\t    prevSvgMode = isSvgMode;\n\n\tif (vnode == null || typeof vnode === 'boolean') vnode = '';\n\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\t\tif (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {\n\t\t\tif (dom.nodeValue != vnode) {\n\t\t\t\tdom.nodeValue = vnode;\n\t\t\t}\n\t\t} else {\n\t\t\tout = document.createTextNode(vnode);\n\t\t\tif (dom) {\n\t\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\t\t\t\trecollectNodeTree(dom, true);\n\t\t\t}\n\t\t}\n\n\t\tout['__preactattr_'] = true;\n\n\t\treturn out;\n\t}\n\n\tvar vnodeName = vnode.nodeName;\n\tif (typeof vnodeName === 'function') {\n\t\treturn buildComponentFromVNode(dom, vnode, context, mountAll);\n\t}\n\n\tisSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;\n\n\tvnodeName = String(vnodeName);\n\tif (!dom || !isNamedNode(dom, vnodeName)) {\n\t\tout = createNode(vnodeName, isSvgMode);\n\n\t\tif (dom) {\n\t\t\twhile (dom.firstChild) {\n\t\t\t\tout.appendChild(dom.firstChild);\n\t\t\t}\n\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\n\t\t\trecollectNodeTree(dom, true);\n\t\t}\n\t}\n\n\tvar fc = out.firstChild,\n\t    props = out['__preactattr_'],\n\t    vchildren = vnode.children;\n\n\tif (props == null) {\n\t\tprops = out['__preactattr_'] = {};\n\t\tfor (var a = out.attributes, i = a.length; i--;) {\n\t\t\tprops[a[i].name] = a[i].value;\n\t\t}\n\t}\n\n\tif (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {\n\t\tif (fc.nodeValue != vchildren[0]) {\n\t\t\tfc.nodeValue = vchildren[0];\n\t\t}\n\t} else if (vchildren && vchildren.length || fc != null) {\n\t\t\tinnerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);\n\t\t}\n\n\tdiffAttributes(out, vnode.attributes, props);\n\n\tisSvgMode = prevSvgMode;\n\n\treturn out;\n}\n\nfunction innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {\n\tvar originalChildren = dom.childNodes,\n\t    children = [],\n\t    keyed = {},\n\t    keyedLen = 0,\n\t    min = 0,\n\t    len = originalChildren.length,\n\t    childrenLen = 0,\n\t    vlen = vchildren ? vchildren.length : 0,\n\t    j,\n\t    c,\n\t    f,\n\t    vchild,\n\t    child;\n\n\tif (len !== 0) {\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar _child = originalChildren[i],\n\t\t\t    props = _child['__preactattr_'],\n\t\t\t    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;\n\t\t\tif (key != null) {\n\t\t\t\tkeyedLen++;\n\t\t\t\tkeyed[key] = _child;\n\t\t\t} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {\n\t\t\t\tchildren[childrenLen++] = _child;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vlen !== 0) {\n\t\tfor (var i = 0; i < vlen; i++) {\n\t\t\tvchild = vchildren[i];\n\t\t\tchild = null;\n\n\t\t\tvar key = vchild.key;\n\t\t\tif (key != null) {\n\t\t\t\tif (keyedLen && keyed[key] !== undefined) {\n\t\t\t\t\tchild = keyed[key];\n\t\t\t\t\tkeyed[key] = undefined;\n\t\t\t\t\tkeyedLen--;\n\t\t\t\t}\n\t\t\t} else if (min < childrenLen) {\n\t\t\t\t\tfor (j = min; j < childrenLen; j++) {\n\t\t\t\t\t\tif (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {\n\t\t\t\t\t\t\tchild = c;\n\t\t\t\t\t\t\tchildren[j] = undefined;\n\t\t\t\t\t\t\tif (j === childrenLen - 1) childrenLen--;\n\t\t\t\t\t\t\tif (j === min) min++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tchild = idiff(child, vchild, context, mountAll);\n\n\t\t\tf = originalChildren[i];\n\t\t\tif (child && child !== dom && child !== f) {\n\t\t\t\tif (f == null) {\n\t\t\t\t\tdom.appendChild(child);\n\t\t\t\t} else if (child === f.nextSibling) {\n\t\t\t\t\tremoveNode(f);\n\t\t\t\t} else {\n\t\t\t\t\tdom.insertBefore(child, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (keyedLen) {\n\t\tfor (var i in keyed) {\n\t\t\tif (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);\n\t\t}\n\t}\n\n\twhile (min <= childrenLen) {\n\t\tif ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);\n\t}\n}\n\nfunction recollectNodeTree(node, unmountOnly) {\n\tvar component = node._component;\n\tif (component) {\n\t\tunmountComponent(component);\n\t} else {\n\t\tif (node['__preactattr_'] != null) applyRef(node['__preactattr_'].ref, null);\n\n\t\tif (unmountOnly === false || node['__preactattr_'] == null) {\n\t\t\tremoveNode(node);\n\t\t}\n\n\t\tremoveChildren(node);\n\t}\n}\n\nfunction removeChildren(node) {\n\tnode = node.lastChild;\n\twhile (node) {\n\t\tvar next = node.previousSibling;\n\t\trecollectNodeTree(node, true);\n\t\tnode = next;\n\t}\n}\n\nfunction diffAttributes(dom, attrs, old) {\n\tvar name;\n\n\tfor (name in old) {\n\t\tif (!(attrs && attrs[name] != null) && old[name] != null) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);\n\t\t}\n\t}\n\n\tfor (name in attrs) {\n\t\tif (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n\t\t}\n\t}\n}\n\nvar recyclerComponents = [];\n\nfunction createComponent(Ctor, props, context) {\n\tvar inst,\n\t    i = recyclerComponents.length;\n\n\tif (Ctor.prototype && Ctor.prototype.render) {\n\t\tinst = new Ctor(props, context);\n\t\tComponent.call(inst, props, context);\n\t} else {\n\t\tinst = new Component(props, context);\n\t\tinst.constructor = Ctor;\n\t\tinst.render = doRender;\n\t}\n\n\twhile (i--) {\n\t\tif (recyclerComponents[i].constructor === Ctor) {\n\t\t\tinst.nextBase = recyclerComponents[i].nextBase;\n\t\t\trecyclerComponents.splice(i, 1);\n\t\t\treturn inst;\n\t\t}\n\t}\n\n\treturn inst;\n}\n\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n\nfunction setComponentProps(component, props, renderMode, context, mountAll) {\n\tif (component._disable) return;\n\tcomponent._disable = true;\n\n\tcomponent.__ref = props.ref;\n\tcomponent.__key = props.key;\n\tdelete props.ref;\n\tdelete props.key;\n\n\tif (typeof component.constructor.getDerivedStateFromProps === 'undefined') {\n\t\tif (!component.base || mountAll) {\n\t\t\tif (component.componentWillMount) component.componentWillMount();\n\t\t} else if (component.componentWillReceiveProps) {\n\t\t\tcomponent.componentWillReceiveProps(props, context);\n\t\t}\n\t}\n\n\tif (context && context !== component.context) {\n\t\tif (!component.prevContext) component.prevContext = component.context;\n\t\tcomponent.context = context;\n\t}\n\n\tif (!component.prevProps) component.prevProps = component.props;\n\tcomponent.props = props;\n\n\tcomponent._disable = false;\n\n\tif (renderMode !== 0) {\n\t\tif (renderMode === 1 || options.syncComponentUpdates !== false || !component.base) {\n\t\t\trenderComponent(component, 1, mountAll);\n\t\t} else {\n\t\t\tenqueueRender(component);\n\t\t}\n\t}\n\n\tapplyRef(component.__ref, component);\n}\n\nfunction renderComponent(component, renderMode, mountAll, isChild) {\n\tif (component._disable) return;\n\n\tvar props = component.props,\n\t    state = component.state,\n\t    context = component.context,\n\t    previousProps = component.prevProps || props,\n\t    previousState = component.prevState || state,\n\t    previousContext = component.prevContext || context,\n\t    isUpdate = component.base,\n\t    nextBase = component.nextBase,\n\t    initialBase = isUpdate || nextBase,\n\t    initialChildComponent = component._component,\n\t    skip = false,\n\t    snapshot = previousContext,\n\t    rendered,\n\t    inst,\n\t    cbase;\n\n\tif (component.constructor.getDerivedStateFromProps) {\n\t\tstate = extend(extend({}, state), component.constructor.getDerivedStateFromProps(props, state));\n\t\tcomponent.state = state;\n\t}\n\n\tif (isUpdate) {\n\t\tcomponent.props = previousProps;\n\t\tcomponent.state = previousState;\n\t\tcomponent.context = previousContext;\n\t\tif (renderMode !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {\n\t\t\tskip = true;\n\t\t} else if (component.componentWillUpdate) {\n\t\t\tcomponent.componentWillUpdate(props, state, context);\n\t\t}\n\t\tcomponent.props = props;\n\t\tcomponent.state = state;\n\t\tcomponent.context = context;\n\t}\n\n\tcomponent.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n\tcomponent._dirty = false;\n\n\tif (!skip) {\n\t\trendered = component.render(props, state, context);\n\n\t\tif (component.getChildContext) {\n\t\t\tcontext = extend(extend({}, context), component.getChildContext());\n\t\t}\n\n\t\tif (isUpdate && component.getSnapshotBeforeUpdate) {\n\t\t\tsnapshot = component.getSnapshotBeforeUpdate(previousProps, previousState);\n\t\t}\n\n\t\tvar childComponent = rendered && rendered.nodeName,\n\t\t    toUnmount,\n\t\t    base;\n\n\t\tif (typeof childComponent === 'function') {\n\n\t\t\tvar childProps = getNodeProps(rendered);\n\t\t\tinst = initialChildComponent;\n\n\t\t\tif (inst && inst.constructor === childComponent && childProps.key == inst.__key) {\n\t\t\t\tsetComponentProps(inst, childProps, 1, context, false);\n\t\t\t} else {\n\t\t\t\ttoUnmount = inst;\n\n\t\t\t\tcomponent._component = inst = createComponent(childComponent, childProps, context);\n\t\t\t\tinst.nextBase = inst.nextBase || nextBase;\n\t\t\t\tinst._parentComponent = component;\n\t\t\t\tsetComponentProps(inst, childProps, 0, context, false);\n\t\t\t\trenderComponent(inst, 1, mountAll, true);\n\t\t\t}\n\n\t\t\tbase = inst.base;\n\t\t} else {\n\t\t\tcbase = initialBase;\n\n\t\t\ttoUnmount = initialChildComponent;\n\t\t\tif (toUnmount) {\n\t\t\t\tcbase = component._component = null;\n\t\t\t}\n\n\t\t\tif (initialBase || renderMode === 1) {\n\t\t\t\tif (cbase) cbase._component = null;\n\t\t\t\tbase = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);\n\t\t\t}\n\t\t}\n\n\t\tif (initialBase && base !== initialBase && inst !== initialChildComponent) {\n\t\t\tvar baseParent = initialBase.parentNode;\n\t\t\tif (baseParent && base !== baseParent) {\n\t\t\t\tbaseParent.replaceChild(base, initialBase);\n\n\t\t\t\tif (!toUnmount) {\n\t\t\t\t\tinitialBase._component = null;\n\t\t\t\t\trecollectNodeTree(initialBase, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toUnmount) {\n\t\t\tunmountComponent(toUnmount);\n\t\t}\n\n\t\tcomponent.base = base;\n\t\tif (base && !isChild) {\n\t\t\tvar componentRef = component,\n\t\t\t    t = component;\n\t\t\twhile (t = t._parentComponent) {\n\t\t\t\t(componentRef = t).base = base;\n\t\t\t}\n\t\t\tbase._component = componentRef;\n\t\t\tbase._componentConstructor = componentRef.constructor;\n\t\t}\n\t}\n\n\tif (!isUpdate || mountAll) {\n\t\tmounts.push(component);\n\t} else if (!skip) {\n\n\t\tif (component.componentDidUpdate) {\n\t\t\tcomponent.componentDidUpdate(previousProps, previousState, snapshot);\n\t\t}\n\t\tif (options.afterUpdate) options.afterUpdate(component);\n\t}\n\n\twhile (component._renderCallbacks.length) {\n\t\tcomponent._renderCallbacks.pop().call(component);\n\t}if (!diffLevel && !isChild) flushMounts();\n}\n\nfunction buildComponentFromVNode(dom, vnode, context, mountAll) {\n\tvar c = dom && dom._component,\n\t    originalComponent = c,\n\t    oldDom = dom,\n\t    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,\n\t    isOwner = isDirectOwner,\n\t    props = getNodeProps(vnode);\n\twhile (c && !isOwner && (c = c._parentComponent)) {\n\t\tisOwner = c.constructor === vnode.nodeName;\n\t}\n\n\tif (c && isOwner && (!mountAll || c._component)) {\n\t\tsetComponentProps(c, props, 3, context, mountAll);\n\t\tdom = c.base;\n\t} else {\n\t\tif (originalComponent && !isDirectOwner) {\n\t\t\tunmountComponent(originalComponent);\n\t\t\tdom = oldDom = null;\n\t\t}\n\n\t\tc = createComponent(vnode.nodeName, props, context);\n\t\tif (dom && !c.nextBase) {\n\t\t\tc.nextBase = dom;\n\n\t\t\toldDom = null;\n\t\t}\n\t\tsetComponentProps(c, props, 1, context, mountAll);\n\t\tdom = c.base;\n\n\t\tif (oldDom && dom !== oldDom) {\n\t\t\toldDom._component = null;\n\t\t\trecollectNodeTree(oldDom, false);\n\t\t}\n\t}\n\n\treturn dom;\n}\n\nfunction unmountComponent(component) {\n\tif (options.beforeUnmount) options.beforeUnmount(component);\n\n\tvar base = component.base;\n\n\tcomponent._disable = true;\n\n\tif (component.componentWillUnmount) component.componentWillUnmount();\n\n\tcomponent.base = null;\n\n\tvar inner = component._component;\n\tif (inner) {\n\t\tunmountComponent(inner);\n\t} else if (base) {\n\t\tif (base['__preactattr_'] != null) applyRef(base['__preactattr_'].ref, null);\n\n\t\tcomponent.nextBase = base;\n\n\t\tremoveNode(base);\n\t\trecyclerComponents.push(component);\n\n\t\tremoveChildren(base);\n\t}\n\n\tapplyRef(component.__ref, null);\n}\n\nfunction Component(props, context) {\n\tthis._dirty = true;\n\n\tthis.context = context;\n\n\tthis.props = props;\n\n\tthis.state = this.state || {};\n\n\tthis._renderCallbacks = [];\n}\n\nextend(Component.prototype, {\n\tsetState: function setState(state, callback) {\n\t\tif (!this.prevState) this.prevState = this.state;\n\t\tthis.state = extend(extend({}, this.state), typeof state === 'function' ? state(this.state, this.props) : state);\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t},\n\tforceUpdate: function forceUpdate(callback) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\trenderComponent(this, 2);\n\t},\n\trender: function render() {}\n});\n\nfunction render(vnode, parent, merge) {\n  return diff(merge, vnode, {}, false, parent, false);\n}\n\nfunction createRef() {\n\treturn {};\n}\n\nvar preact = {\n\th: h,\n\tcreateElement: h,\n\tcloneElement: cloneElement,\n\tcreateRef: createRef,\n\tComponent: Component,\n\trender: render,\n\trerender: rerender,\n\toptions: options\n};\n\nexport default preact;\nexport { h, h as createElement, cloneElement, createRef, Component, render, rerender, options };\n//# sourceMappingURL=preact.mjs.map\n","/*\nCopyright (c) 2019 Daybrush\nname: keycon\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/keycon.git\nversion: 0.2.2\n*/\nimport Component from '@egjs/component';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar keycode = createCommonjsModule(function (module, exports) {\n// Source: http://jsfiddle.net/vWx8V/\n// http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes\n\n/**\n * Conenience method returns corresponding value for given keyName or keyCode.\n *\n * @param {Mixed} keyCode {Number} or keyName {String}\n * @return {Mixed}\n * @api public\n */\nfunction keyCode(searchInput) {\n  // Keyboard Events\n  if (searchInput && 'object' === typeof searchInput) {\n    var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;\n    if (hasKeyCode) searchInput = hasKeyCode;\n  } // Numbers\n\n\n  if ('number' === typeof searchInput) return names[searchInput]; // Everything else (cast to string)\n\n  var search = String(searchInput); // check codes\n\n  var foundNamedKey = codes[search.toLowerCase()];\n  if (foundNamedKey) return foundNamedKey; // check aliases\n\n  var foundNamedKey = aliases[search.toLowerCase()];\n  if (foundNamedKey) return foundNamedKey; // weird character?\n\n  if (search.length === 1) return search.charCodeAt(0);\n  return undefined;\n}\n/**\n * Compares a keyboard event with a given keyCode or keyName.\n *\n * @param {Event} event Keyboard event that should be tested\n * @param {Mixed} keyCode {Number} or keyName {String}\n * @return {Boolean}\n * @api public\n */\n\n\nkeyCode.isEventKey = function isEventKey(event, nameOrCode) {\n  if (event && 'object' === typeof event) {\n    var keyCode = event.which || event.keyCode || event.charCode;\n\n    if (keyCode === null || keyCode === undefined) {\n      return false;\n    }\n\n    if (typeof nameOrCode === 'string') {\n      // check codes\n      var foundNamedKey = codes[nameOrCode.toLowerCase()];\n\n      if (foundNamedKey) {\n        return foundNamedKey === keyCode;\n      } // check aliases\n\n\n      var foundNamedKey = aliases[nameOrCode.toLowerCase()];\n\n      if (foundNamedKey) {\n        return foundNamedKey === keyCode;\n      }\n    } else if (typeof nameOrCode === 'number') {\n      return nameOrCode === keyCode;\n    }\n\n    return false;\n  }\n};\n\nexports = module.exports = keyCode;\n/**\n * Get by name\n *\n *   exports.code['enter'] // => 13\n */\n\nvar codes = exports.code = exports.codes = {\n  'backspace': 8,\n  'tab': 9,\n  'enter': 13,\n  'shift': 16,\n  'ctrl': 17,\n  'alt': 18,\n  'pause/break': 19,\n  'caps lock': 20,\n  'esc': 27,\n  'space': 32,\n  'page up': 33,\n  'page down': 34,\n  'end': 35,\n  'home': 36,\n  'left': 37,\n  'up': 38,\n  'right': 39,\n  'down': 40,\n  'insert': 45,\n  'delete': 46,\n  'command': 91,\n  'left command': 91,\n  'right command': 93,\n  'numpad *': 106,\n  'numpad +': 107,\n  'numpad -': 109,\n  'numpad .': 110,\n  'numpad /': 111,\n  'num lock': 144,\n  'scroll lock': 145,\n  'my computer': 182,\n  'my calculator': 183,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  \"'\": 222 // Helper aliases\n\n};\nvar aliases = exports.aliases = {\n  'windows': 91,\n  '⇧': 16,\n  '⌥': 18,\n  '⌃': 17,\n  '⌘': 91,\n  'ctl': 17,\n  'control': 17,\n  'option': 18,\n  'pause': 19,\n  'break': 19,\n  'caps': 20,\n  'return': 13,\n  'escape': 27,\n  'spc': 32,\n  'spacebar': 32,\n  'pgup': 33,\n  'pgdn': 34,\n  'ins': 45,\n  'del': 46,\n  'cmd': 91\n  /*!\n   * Programatically add the following\n   */\n  // lower case chars\n\n};\n\nfor (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32; // numbers\n\n\nfor (var i = 48; i < 58; i++) codes[i - 48] = i; // function keys\n\n\nfor (i = 1; i < 13; i++) codes['f' + i] = i + 111; // numpad keys\n\n\nfor (i = 0; i < 10; i++) codes['numpad ' + i] = i + 96;\n/**\n * Get by code\n *\n *   exports.name[13] // => 'Enter'\n */\n\n\nvar names = exports.names = exports.title = {}; // title for backward compat\n// Create reverse mapping\n\nfor (i in codes) names[codes[i]] = i; // Add aliases\n\n\nfor (var alias in aliases) {\n  codes[alias] = aliases[alias];\n}\n});\nvar keycode_1 = keycode.code;\nvar keycode_2 = keycode.codes;\nvar keycode_3 = keycode.aliases;\nvar keycode_4 = keycode.names;\nvar keycode_5 = keycode.title;\n\n/*\nCopyright (c) 2018 Daybrush\n@name: @daybrush/utils\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/utils\n@version 0.7.1\n*/\n/**\n* get string \"string\"\n* @memberof Consts\n* @example\nimport {STRING} from \"@daybrush/utils\";\n\nconsole.log(STRING); // \"string\"\n*/\n\nvar STRING = \"string\";\n/**\n* Check the type that the value is isArray.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isArray} from \"@daybrush/utils\";\n\nconsole.log(isArray([])); // true\nconsole.log(isArray({})); // false\nconsole.log(isArray(undefined)); // false\nconsole.log(isArray(null)); // false\n*/\n\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n/**\n* Check the type that the value is string.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isString} from \"@daybrush/utils\";\n\nconsole.log(isString(\"1234\")); // true\nconsole.log(isString(undefined)); // false\nconsole.log(isString(1)); // false\nconsole.log(isString(null)); // false\n*/\n\n\nfunction isString(value) {\n  return typeof value === STRING;\n}\n/**\n* Sets up a function that will be called whenever the specified event is delivered to the target\n* @memberof DOM\n* @param - event target\n* @param - A case-sensitive string representing the event type to listen for.\n* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs\n* @param - An options object that specifies characteristics about the event listener. The available options are:\n* @example\nimport {addEvent} from \"@daybrush/utils\";\n\naddEvent(el, \"click\", e => {\n  console.log(e);\n});\n*/\n\n\nfunction addEvent(el, type, listener, options) {\n  el.addEventListener(type, listener, options);\n}\n\nvar codeData = {\n  \"+\": \"plus\",\n  \"left command\": \"meta\",\n  \"right command\": \"meta\"\n};\nvar keysSort = {\n  shift: 1,\n  ctrl: 2,\n  alt: 3,\n  meta: 4\n};\n\nfunction getKey(keyCode) {\n  var key = keycode_4[keyCode] || \"\";\n\n  for (var name in codeData) {\n    key = key.replace(name, codeData[name]);\n  }\n\n  return key.replace(/\\s/g, \"\");\n}\n\nfunction getCombi(e, key) {\n  var keys = [e.shiftKey && \"shift\", e.ctrlKey && \"ctrl\", e.altKey && \"alt\", e.metaKey && \"meta\"];\n  keys.indexOf(key) === -1 && keys.push(key);\n  return keys.filter(Boolean);\n}\n\nfunction getArrangeCombi(keys) {\n  var arrangeKeys = keys.slice();\n  arrangeKeys.sort(function (prev, next) {\n    var prevScore = keysSort[prev] || 5;\n    var nextScore = keysSort[next] || 5;\n    return prevScore - nextScore;\n  });\n  return arrangeKeys;\n}\n/**\n */\n\n\nvar KeyController =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(KeyController, _super);\n  /**\n   *\n   */\n\n\n  function KeyController(container) {\n    if (container === void 0) {\n      container = window;\n    }\n\n    var _this = _super.call(this) || this;\n    /**\n     */\n\n\n    _this.ctrlKey = false;\n    /**\n     */\n\n    _this.altKey = false;\n    /**\n     *\n     */\n\n    _this.shiftKey = false;\n    /**\n     *\n     */\n\n    _this.metaKey = false;\n\n    _this.clear = function () {\n      _this.ctrlKey = false;\n      _this.altKey = false;\n      _this.shiftKey = false;\n      _this.metaKey = false;\n    };\n\n    _this.keydownEvent = function (e) {\n      _this.triggerEvent(\"keydown\", e);\n    };\n\n    _this.keyupEvent = function (e) {\n      _this.triggerEvent(\"keyup\", e);\n    };\n\n    addEvent(container, \"blur\", _this.clear);\n    addEvent(container, \"keydown\", _this.keydownEvent);\n    addEvent(container, \"keyup\", _this.keyupEvent);\n    return _this;\n  }\n  /**\n   *\n   */\n\n\n  var __proto = KeyController.prototype;\n\n  __proto.keydown = function (comb, callback) {\n    return this.addEvent(\"keydown\", comb, callback);\n  };\n  /**\n   *\n   */\n\n\n  __proto.keyup = function (comb, callback) {\n    return this.addEvent(\"keyup\", comb, callback);\n  };\n\n  __proto.addEvent = function (type, comb, callback) {\n    if (isArray(comb)) {\n      this.on(type + \".\" + getArrangeCombi(comb).join(\".\"), callback);\n    } else if (isString(comb)) {\n      this.on(type + \".\" + comb, callback);\n    } else {\n      this.on(type, comb);\n    }\n\n    return this;\n  };\n\n  __proto.triggerEvent = function (type, e) {\n    this.ctrlKey = e.ctrlKey;\n    this.shiftKey = e.shiftKey;\n    this.altKey = e.altKey;\n    this.metaKey = e.metaKey;\n    var key = getKey(e.keyCode);\n    var isToggle = key === \"ctrl\" || key === \"shift\" || key === \"meta\" || key === \"alt\";\n    var param = {\n      key: key,\n      isToggle: isToggle,\n      inputEvent: e,\n      keyCode: e.keyCode,\n      ctrlKey: e.ctrlKey,\n      altKey: e.altKey,\n      shiftKey: e.shiftKey,\n      metaKey: e.metaKey\n    };\n    this.trigger(type, param);\n    this.trigger(type + \".\" + key, param);\n    var combi = getCombi(e, key);\n    combi.length > 1 && this.trigger(type + \".\" + combi.join(\".\"), param);\n  };\n\n  return KeyController;\n}(Component);\n\nexport default KeyController;\n//# sourceMappingURL=keycon.esm.js.map\n","/*\nCopyright (c) 2019 Daybrush\nname: @daybrush/drag\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/drag.git\nversion: 0.4.2\n*/\nfunction setDrag(el, options) {\n  var flag = false;\n  var startX = 0;\n  var startY = 0;\n  var prevX = 0;\n  var prevY = 0;\n  var datas = {};\n  var isDrag = false;\n  var _a = options.container,\n      container = _a === void 0 ? el : _a,\n      dragstart = options.dragstart,\n      drag = options.drag,\n      dragend = options.dragend,\n      _b = options.events,\n      events = _b === void 0 ? [\"touch\", \"mouse\"] : _b;\n  var isTouch = events.indexOf(\"touch\") > -1;\n  var isMouse = events.indexOf(\"mouse\") > -1;\n\n  function getPosition(e) {\n    return e.touches && e.touches.length ? e.touches[0] : e;\n  }\n\n  function onDragStart(e) {\n    flag = true;\n    isDrag = false;\n\n    var _a = getPosition(e),\n        clientX = _a.clientX,\n        clientY = _a.clientY;\n\n    startX = clientX;\n    startY = clientY;\n    prevX = clientX;\n    prevY = clientY;\n    datas = {};\n    (dragstart && dragstart({\n      datas: datas,\n      inputEvent: e,\n      clientX: clientX,\n      clientY: clientY\n    })) === false && (flag = false);\n    flag && e.preventDefault();\n  }\n\n  function onDrag(e) {\n    if (!flag) {\n      return;\n    }\n\n    var _a = getPosition(e),\n        clientX = _a.clientX,\n        clientY = _a.clientY;\n\n    var deltaX = clientX - prevX;\n    var deltaY = clientY - prevY;\n\n    if (!deltaX && !deltaY) {\n      return;\n    }\n\n    isDrag = true;\n    drag && drag({\n      datas: datas,\n      clientX: clientX,\n      clientY: clientY,\n      deltaX: deltaX,\n      deltaY: deltaY,\n      distX: clientX - startX,\n      distY: clientY - startY,\n      inputEvent: e\n    });\n    prevX = clientX;\n    prevY = clientY;\n  }\n\n  function onDragEnd(e) {\n    if (!flag) {\n      return;\n    }\n\n    flag = false;\n    dragend && dragend({\n      datas: datas,\n      isDrag: isDrag,\n      inputEvent: e,\n      clientX: prevX,\n      clientY: prevY,\n      distX: prevX - startX,\n      distY: prevY - startY\n    });\n  }\n\n  if (isMouse) {\n    el.addEventListener(\"mousedown\", onDragStart);\n    container.addEventListener(\"mousemove\", onDrag);\n    container.addEventListener(\"mouseup\", onDragEnd); // container.addEventListener(\"mouseleave\", onDragEnd);\n  }\n\n  if (isTouch) {\n    el.addEventListener(\"touchstart\", onDragStart);\n    container.addEventListener(\"touchmove\", onDrag);\n    container.addEventListener(\"touchend\", onDragEnd);\n  }\n}\n\nexport { setDrag as drag };\n","/*! Hammer.JS - v2.0.15 - 2019-04-04\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\n\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nvar assign$1 = assign;\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n    abs = Math.abs;\nvar now = Date.now;\n\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n\n    i++;\n  }\n\n  return undefined;\n}\n\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {};\n} else {\n  win = window;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = 'ontouchstart' in win;\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n  var i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\n\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n\n  return val;\n}\n\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\n\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\nvar TouchAction =\n/*#__PURE__*/\nfunction () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n\n  var _proto = TouchAction.prototype;\n\n  _proto.set = function set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n\n    this.actions = value.toLowerCase().trim();\n  };\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n\n  return TouchAction;\n}();\n\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  var x = 0;\n  var y = 0;\n  var i = 0;\n\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\n\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\nfunction computeDeltaXY(session, input) {\n  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  var firstInput = session.firstInput,\n      firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input); // find the correct target\n\n  var target = manager.element;\n\n  if (hasParent(input.srcEvent.target, target)) {\n    target = input.srcEvent.target;\n  }\n\n  input.target = target;\n}\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  computeInputData(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\nvar Input =\n/*#__PURE__*/\nfunction () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n\n  var _proto = Input.prototype;\n\n  _proto.handler = function handler() {};\n  /**\n   * @private\n   * bind the events\n   */\n\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  /**\n   * @private\n   * unbind the events\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n\n  return Input;\n}();\n\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n\n      i++;\n    }\n\n    return -1;\n  }\n}\n\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n};\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\n\nvar PointerEventInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n\n  function PointerEventInput() {\n    var _this;\n\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = PointerEventInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  };\n\n  return PointerEventInput;\n}(Input);\n\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n\n  function TouchInput() {\n    var _this;\n\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;\n\n    return _this;\n  }\n\n  var _proto = TouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return TouchInput;\n}(Input);\n\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target; // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  }); // collect touches\n\n  if (type === INPUT_START) {\n    i = 0;\n\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n  i = 0;\n\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\n\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n\n  function MouseInput() {\n    var _this;\n\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false; // mousedown state\n\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = MouseInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    } // mouse must be down\n\n\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n\n  return MouseInput;\n}(Input);\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n      touch = _eventData$changedPoi[0];\n\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\n\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\n\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar TouchMouseInput =\n/*#__PURE__*/\nfunction () {\n  var TouchMouseInput =\n  /*#__PURE__*/\n  function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n\n      _this = _Input.call(this, _manager, callback) || this;\n\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {\n          return;\n        }\n\n        _this.callback(manager, inputEvent, inputData);\n      };\n\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    /**\n     * @private\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n\n\n    var _proto = TouchMouseInput.prototype;\n\n    /**\n     * @private\n     * remove the event listeners\n     */\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n\n    return TouchMouseInput;\n  }(Input);\n\n  return TouchMouseInput;\n}();\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\n\nfunction createInputInstance(manager) {\n  var Type; // let inputClass = manager.options.inputClass;\n\n  var inputClass = manager.options.inputClass;\n\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n\n  return new Type(manager, inputHandler);\n}\n\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n\n  return false;\n}\n\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n  return _uniqueId++;\n}\n\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n\n  return otherRecognizer;\n}\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n\n  return '';\n}\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\nvar Recognizer =\n/*#__PURE__*/\nfunction () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n\n  var _proto = Recognizer.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n\n    this.state = STATE_FAILED;\n  };\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n\n  _proto.process = function process(inputData) {};\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n\n  _proto.getTouchAction = function getTouchAction() {};\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n\n  _proto.reset = function reset() {};\n\n  return Recognizer;\n}();\n\nvar defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Default recognizer setup when calling `Hammer()`\n   * When creating a new Manager these will be skipped.\n   * @type {Array}\n   */\n  preset: [],\n\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: \"none\",\n\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: \"none\",\n\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: \"none\",\n\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: \"none\",\n\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: \"none\",\n\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n\n  if (!element.style) {\n    return;\n  }\n\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\n\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\n\nvar Manager =\n/*#__PURE__*/\nfunction () {\n  function Manager(element, options) {\n    var _this = this;\n\n    this.options = assign$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n\n  var _proto = Manager.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    var i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && ( // 1\n      !curRecognizer || recognizer === curRecognizer || // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n\n      i++;\n    }\n  };\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    var recognizers = this.recognizers;\n\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    } // remove existing\n\n\n    var existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  _proto.emit = function emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    } // no handlers, so skip it all\n\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    var i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n\n  return Manager;\n}();\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n\n  function SingleTouchInput() {\n    var _this;\n\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n\n  var _proto = SingleTouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return SingleTouchInput;\n}(Input);\n\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\nvar AttrRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n\n  var _proto = AttrRecognizer.prototype;\n\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n\n      return state | STATE_CHANGED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  return AttrRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\nvar TapRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n\n  function TapRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10\n    }, options)) || this; // previous time and center,\n    // used for tap counting\n\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  var _proto = TapRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      var tapCount = this.count % options.taps;\n\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return TapRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n\n  return '';\n}\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PanRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n\n  function PanRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n\n  var _proto = PanRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n\n    return actions;\n  };\n\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call\n    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PanRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar SwipeRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n\n  var _proto = SwipeRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  };\n\n  return SwipeRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PinchRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PinchRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar RotateRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = RotateRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  return RotateRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\nvar PressRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n\n  function PressRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n\n  var _proto = PressRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return PressRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n\n    return method.apply(this, arguments);\n  };\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n\n    i++;\n  }\n\n  return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\n\nvar merge = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\n\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Hammer =\n/*#__PURE__*/\nfunction () {\n  var Hammer =\n  /**\n    * @private\n    * @const {string}\n    */\n  function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new Manager(element, _extends({\n      recognizers: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n      [RotateRecognizer, {\n        enable: false\n      }], [PinchRecognizer, {\n        enable: false\n      }, ['rotate']], [SwipeRecognizer, {\n        direction: DIRECTION_HORIZONTAL\n      }], [PanRecognizer, {\n        direction: DIRECTION_HORIZONTAL\n      }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n        event: 'doubletap',\n        taps: 2\n      }, ['tap']], [PressRecognizer]]\n    }, options));\n  };\n\n  Hammer.VERSION = \"2.0.15\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = defaults;\n  return Hammer;\n}();\n\nexport default Hammer;\nexport { INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_ENDED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, DIRECTION_NONE, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, Manager, Input, TouchAction, TouchInput, MouseInput, PointerEventInput, TouchMouseInput, SingleTouchInput, Recognizer, AttrRecognizer, TapRecognizer as Tap, PanRecognizer as Pan, SwipeRecognizer as Swipe, PinchRecognizer as Pinch, RotateRecognizer as Rotate, PressRecognizer as Press, addEventListeners as on, removeEventListeners as off, each, merge, extend, assign$1 as assign, inherit, bindFn, prefixed, toArray, inArray, uniqueArray, splitStr, boolOrFn, hasParent, addEventListeners, removeEventListeners, defaults };\n//# sourceMappingURL=hammer.esm.js.map\n","import PreactTimeline from \"preact-timeline\";\nimport EgComponent from \"@egjs/component\";\nimport { VNode, h, render, Component } from \"preact\";\nimport Scene, { SceneItem } from \"scenejs\";\nimport { TimelineProps, SelectEvent } from \"./types\";\n\nexport default class Timeline extends EgComponent {\n    private timelineArea!: PreactTimeline;\n    constructor(scene: Scene | SceneItem, parentElement: Element, options: TimelineProps = {}) {\n        super();\n        const element = document.createElement(\"div\");\n        render(\n            <PreactTimeline\n                ref={e => { e && (this.timelineArea = e as PreactTimeline) }}\n                keyboard={true}\n                {...options}\n                scene={scene}\n                onSelect={this.onSelect}\n            />,\n            element,\n        );\n\n        parentElement.appendChild(element.children[0]);\n    }\n    public update(isInit?: boolean) {\n        this.timelineArea.update(isInit);\n    }\n    private onSelect = (e: SelectEvent) => {\n        this.trigger(\"select\", e);\n    }\n}\n"],"names":["VNode","options","stack","EMPTY_CHILDREN","h","nodeName","attributes","lastSimple","child","simple","i","children","arguments","length","push","pop","undefined","String","p","key","vnode","extend","obj","props","applyRef","ref","value","current","defer","Promise","resolve","then","bind","setTimeout","IS_NON_DIMENSIONAL","items","enqueueRender","component","_dirty","rerender","renderComponent","isNamedNode","node","normalizedNodeName","toLowerCase","getNodeProps","defaultProps","removeNode","parentNode","removeChild","setAccessor","name","old","isSvg","style","cssText","test","innerHTML","__html","useCapture","replace","substring","addEventListener","eventProxy","removeEventListener","_listeners","e","removeAttribute","ns","removeAttributeNS","setAttributeNS","setAttribute","className","this","type","event","mounts","diffLevel","isSvgMode","hydrating","flushMounts","c","shift","componentDidMount","diff","dom","context","mountAll","parent","componentRoot","ownerSVGElement","ret","idiff","appendChild","out","prevSvgMode","splitText","_component","nodeValue","document","createTextNode","replaceChild","recollectNodeTree","vnodeName","originalComponent","oldDom","isDirectOwner","_componentConstructor","isOwner","_parentComponent","constructor","setComponentProps","base","unmountComponent","createComponent","nextBase","buildComponentFromVNode","createElementNS","createElement","createNode","firstChild","fc","vchildren","a","nextSibling","isHydrating","j","f","vchild","originalChildren","childNodes","keyed","keyedLen","min","len","childrenLen","vlen","_child","__key","trim","insertBefore","innerDiffNode","dangerouslySetInnerHTML","attrs","diffAttributes","unmountOnly","removeChildren","lastChild","next","previousSibling","recyclerComponents","Ctor","inst","prototype","render","Component","call","doRender","splice","state","renderMode","_disable","__ref","getDerivedStateFromProps","componentWillMount","componentWillReceiveProps","prevContext","prevProps","syncComponentUpdates","isChild","rendered","cbase","previousProps","previousState","prevState","previousContext","isUpdate","initialBase","initialChildComponent","skip","snapshot","shouldComponentUpdate","componentWillUpdate","getChildContext","getSnapshotBeforeUpdate","toUnmount","childComponent","childProps","baseParent","componentRef","t","componentDidUpdate","_renderCallbacks","componentWillUnmount","inner","setState","callback","forceUpdate","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","hasOwnProperty","module","keycode","exports","keyCode","searchInput","hasKeyCode","which","charCode","names","foundNamedKey","search","codes","aliases","charCodeAt","isEventKey","nameOrCode","code","fromCharCode","title","alias","fn","keycode_4","addEvent","el","listener","codeData","keysSort","ctrl","alt","meta","KeyController","_super","container","window","_this","ctrlKey","altKey","shiftKey","metaKey","clear","keydownEvent","triggerEvent","keyupEvent","__","create","__extends","__proto","keydown","comb","keyup","isArray","isString","on","keys","arrangeKeys","slice","sort","prev","getArrangeCombi","join","getKey","param","isToggle","inputEvent","trigger","combi","indexOf","filter","Boolean","getCombi","setDrag","flag","startX","startY","prevX","prevY","datas","isDrag","_a","dragstart","drag","dragend","_b","events","isTouch","getPosition","touches","onDragStart","clientX","clientY","preventDefault","onDrag","deltaX","deltaY","distX","distY","onDragEnd","_extends","assign","target","source","apply","_inheritsLoose","subClass","superClass","_assertThisInitialized","self","ReferenceError","win","assign$1","TypeError","output","index","nextKey","VENDOR_PREFIXES","TEST_ELEMENT","TYPE_FUNCTION","round","Math","abs","now","Date","prefixed","property","prefix","prop","camelProp","toUpperCase","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MAP","touchMap","cssSupports","CSS","supports","forEach","val","getTouchActionProps","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_MOUSE","COMPUTE_INTERVAL","INPUT_START","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","PROPS_CLIENT_XY","each","iterator","boolOrFn","args","inStr","str","find","TouchAction","manager","set","_proto","compute","element","actions","update","touchAction","recognizers","recognizer","enable","concat","getTouchAction","hasPanX","hasPanY","cleanTouchActions","preventDefaults","input","srcEvent","direction","offsetDirection","session","prevented","hasNone","isTapPointer","pointers","isTapMovement","distance","isTapTouchTime","deltaTime","preventSrc","hasParent","getCenter","pointersLength","x","y","simpleCloneInputData","timeStamp","center","getDistance","p1","p2","sqrt","getAngle","atan2","PI","getDirection","getVelocity","computeInputData","firstInput","firstMultiple","offsetCenter","angle","offset","offsetDelta","prevDelta","prevInput","eventType","computeDeltaXY","overallVelocity","overallVelocityX","overallVelocityY","scale","start","end","getScale","rotation","getRotation","maxPointers","velocity","velocityX","velocityY","last","lastInterval","v","computeIntervalInputData","inputHandler","pointersLen","changedPointersLen","changedPointers","isFirst","isFinal","emit","recognize","splitStr","split","addEventListeners","types","handler","removeEventListeners","getWindowForElement","doc","ownerDocument","defaultView","parentWindow","Input","inputTarget","domHandler","ev","init","evEl","evTarget","evWin","destroy","inArray","src","findByKey","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","MSPointerEvent","PointerEvent","PointerEventInput","_Input","proto","store","pointerEvents","removePointer","eventTypeNormalized","pointerType","storeIndex","pointerId","button","toArray","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TouchInput","targetIds","targetTouches","allTouches","identifier","changedTouches","changedTargetTouches","touch","results","values","uniqueArray","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MouseInput","pressed","DEDUP_TIMEOUT","DEDUP_DISTANCE","setLastTouch","eventData","primaryTouch","lastTouch","lts","lastTouches","TouchMouseInput","_manager","inputData","isMouse","sourceCapabilities","firesTouchEvents","dx","dy","mouse","invokeArrayArg","arg","_uniqueId","getRecognizerByNameIfManager","otherRecognizer","get","stateStr","Recognizer","id","simultaneous","requireFail","recognizeWith","dropRecognizeWith","requireFailure","dropRequireFailure","hasRequireFailures","canRecognizeWith","additionalEvent","tryEmit","canEmit","inputDataClone","reset","process","defaults","domEvents","inputClass","preset","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","toggleCssProps","add","oldCssProps","Manager","handlers","createInputInstance","item","stop","force","stopped","curRecognizer","existing","remove","targetRecognizer","off","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","triggerDomEvent","PinchRecognizer","_AttrRecognizer","threshold","attrTest","inOut","_Recognizer","AttrRecognizer","optionPointers","isRecognized","isValid","scene","parentElement","merge","PreactTimeline","timelineArea","keyboard","onSelect","tslib_1","isInit","EgComponent"],"mappings":"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"}