{"version":3,"file":"timeline.min.js","sources":["../src/consts.ts","../src/utils.ts","../src/dblcheck.ts","../src/HeaderAreaStructure.ts","../src/KeytimesStructure.ts","../src/KeyframesStructure.ts","../src/ScrollAreaStructure.ts","../src/PropertiesStructure.ts","../src/ValuesStructure.ts","../src/TimelineInfo.ts","../src/Timeline.ts","../src/ControlAreaStructure.ts"],"sourcesContent":["export const PREFIX = `scenejs_editor_`;\nexport const SUPPORT_POINTER_EVENTS = \"PointerEvent\" in window || \"MSPointerEvent\" in window;\nexport const SUPPORT_TOUCH = \"ontouchstart\" in window;\n\nexport const CSS2 = `\n.item_info {\n    position: fixed;\n    right: 0;\n    top: 0;\n    width: 200px;\n    background: #000;\n}\n.options_area {\n\n}\n.option_area {\n    position: relative;\n    border-bottom: 1px solid #777;\n    box-sizing: border-box;\n    white-space: nowrap;\n    background: rgba(90, 90, 90, 0.7);\n    font-size: 13px;\n    font-weight: bold;\n    color: #eee;\n    display: flex;\n}\n.option_name, .option_value {\n    width: 50%;\n    height: 30px;\n    line-height: 20px;\n    box-sizing: border-box;\n    padding: 5px;\n}\n.option_name {\n    border-right: 1px solid #999;\n}\n.option_value input {\n    appearance: none;\n    -webkit-appearance: none;\n    outline: none;\n    position: relative;\n    display: block;\n    width: 100%;\n    height: 100%;\n    background: transparent;\n    color: #4af;\n    font-weight: bold;\n    background: none;\n    border: 0;\n    box-sizing: border-box;\n}\n`.replace(/\\.([^{,\\s\\d.]+)/g, `.${PREFIX}$1`);\n\nexport const CSS = `\n.timeline * {\n    box-sizing: border-box;\n}\n.timeline {\n  position: fixed;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  width: 100%;\n  font-size: 0;\n  background: #000;\n  display: flex;\n  flex-direction: column;\n}\n.header_area, .scroll_area {\n   width: 100%;\n   position: relative;\n  display: flex;\n  -webkit-align-items: flex-start;\n  align-items: flex-start;\n}\n.header_area {\n  position: relative;\n  z-index: 10;\n  top: 0;\n  height: 30px;\n  min-height: 30px;\n}\n.header_area .keyframes {\n  padding: 0px;\n}\n.header_area .properties_area,\n.header_area .keyframes_area,\n.header_area .values_area,\n.header_area .keyframes_scroll_area {\n    height: 100%;\n}\n.header_area .property, .header_area .value, .header_area .keyframes {\n  height: 100%;\n}\n.header_area .property {\n    line-height: 30px;\n}\n.value .add {\n    text-align: center;\n    color: #fff;\n    line-height: 30px;\n    font-weight: bold;\n    font-size: 20px;\n    cursor: pointer;\n}\n.header_area .keyframes_area::-webkit-scrollbar {\n    display: none; // Safari and Chrome\n}\n.header_area .keyframe_cursor {\n    position: absolute;\n    border-top: 10px solid #4af;\n    border-left: 6px solid transparent;\n    border-right: 6px solid transparent;\n    width: 0;\n    height: 0;\n    bottom: 0;\n    top: auto;\n    background: none;\n    cursor: pointer;\n}\n.control_area .keyframes {\n    padding-left: 10px;\n}\n.play_control_area {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n.play_control_area .control {\n    position: relative;\n    display: inline-block;\n    vertical-align: middle;\n    color: white;\n    margin: 0px 15px;\n}\n.play {\n    border-left: 14px solid white;\n    border-top: 8px solid transparent;\n    border-bottom: 8px solid transparent;\n}\n.pause {\n    border-left: 4px solid #fff;\n    border-right: 4px solid #fff;\n    width: 14px;\n    height: 16px;\n}\n.prev {\n    border-right: 10px solid white;\n    border-top: 6px solid transparent;\n    border-bottom: 6px solid transparent;\n}\n.prev:before {\n    position: absolute;\n    content: \"\";\n    width: 3px;\n    height: 10px;\n    top: 0;\n    right: 100%;\n    transform: translate(0, -50%);\n    background: white;\n}\n.next {\n    border-left: 10px solid white;\n    border-top: 6px solid transparent;\n    border-bottom: 6px solid transparent;\n}\n.next:before {\n    position: absolute;\n    content: \"\";\n    width: 3px;\n    height: 10px;\n    top: 0;\n    transform: translate(0, -50%);\n    background: white;\n}\n.keytime {\n  position: relative;\n  display: inline-block;\n  height: 100%;\n  font-size: 13px;\n  font-weight: bold;\n  color: #777;\n}\n.keytime:last-child {\n  max-width: 0px;\n}\n.keytime span {\n  position: absolute;\n  line-height: 1;\n  bottom: 12px;\n  display: inline-block;\n  transform: translate(-50%);\n  color: #eee;\n}\n.keytime .graduation {\n  position: absolute;\n  bottom: 0;\n  width: 1px;\n  height: 10px;\n  background: #777;\n  transform: translate(-50%);\n}\n.keytime .graduation.half {\n  left: 50%;\n  height: 7px;\n}\n.keytime .graduation.quarter {\n  left: 25%;\n  height: 5px;\n}\n.keytime .graduation.quarter3 {\n  left: 75%;\n  height: 5px;\n}\n.scroll_area {\n  position: relative;\n  width: 100%;\n  height: calc(100% - 60px);\n  overflow: auto;\n}\n.properties_area, .keyframes_area, .values_area {\n  display: inline-block;\n  position: relative;\n  font-size: 16px;\n  overflow: auto;\n}\n\n.properties_area::-webkit-scrollbar, .keyframes_area::-webkit-scrollbar {\n    display: none; // Safari and Chrome\n}\n.properties_area {\n  width: 30%;\n  max-width: 200px;\n  box-sizing: border-box;\n}\n.values_area {\n    width: 50px;\n    min-width: 50px;\n    display: inline-block;\n    border-right: 1px solid #999;\n    box-sizing: border-box;\n}\n.value input {\n    appearance: none;\n    -webkit-appearance: none;\n    outline: none;\n    position: relative;\n    display: block;\n    width: 100%;\n    height: 100%;\n    background: transparent;\n    color: #4af;\n    font-weight: bold;\n    background: none;\n    border: 0;\n    box-sizing: border-box;\n    text-align: center;\n}\n.value {\n\n}\n.alt .value input {\n    cursor: ew-resize;\n}\n.value[data-object=\"1\"] input {\n    display: none;\n}\n.properties_scroll_area {\n  display: inline-block;\n  min-width: 100%;\n}\n.keyframes_area {\n  flex: 1;\n}\n.keyframes_scroll_area {\n  position: relative;\n  min-width: 300px;\n}\n.keyframes, .property, .value {\n  position: relative;\n  height: 30px;\n  line-height: 30px;\n  border-bottom: 1px solid #777;\n  box-sizing: border-box;\n  white-space: nowrap;\n  background: rgba(90, 90, 90, 0.7);\n  z-index: 1;\n}\n\n.property {\n  padding-left: 10px;\n  box-sizing: border-box;\n  font-size: 13px;\n  font-weight: bold;\n  color: #eee;\n}\n.property .remove {\n    position: absolute;\n    display: inline-block;\n    cursor: pointer;\n    width: 18px;\n    height: 18px;\n    top: 0;\n    bottom: 0;\n    right: 10px;\n    margin: auto;\n    border-radius: 50%;\n    border: 2px solid #fff;\n    vertical-align: middle;\n    display: none;\n    margin-left: 10px;\n    box-sizing: border-box;\n}\n.property .remove:before, .property .remove:after {\n    position: absolute;\n    content: \"\";\n    width: 8px;\n    height: 2px;\n    border-radius: 1px;\n    background: #fff;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    margin: auto;\n}\n.property .remove:before {\n    transform: rotate(45deg);\n}\n.property .remove:after {\n    transform: rotate(-45deg);\n}\n.property:hover .remove {\n    display: inline-block;\n}\n\n[data-item=\"1\"], [data-item=\"1\"] .add {\n    height: 30px;\n    line-height: 30px;\n}\n.time_area {\n    position: absolute;\n    top: 0;\n    left: 10px;\n    font-size: 13px;\n    color: #4af;\n    line-height: 30px;\n    font-weight: bold;\n    height: 100%;\n    line-height: 30px;\n    border: 0;\n    background: transparent;\n    outline: 0;\n}\n.time_area:after {\n    content: \"s\";\n}\n.property .arrow {\n    position: relative;\n    display: inline-block;\n    width: 20px;\n    height: 25px;\n    cursor: pointer;\n    vertical-align: middle;\n}\n.property .arrow:after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    right: 0;\n    left: 0;\n    bottom: 0;\n    margin: auto;\n    width: 0;\n    height: 0;\n    border-top: 6px solid #eee;\n    border-left: 4px solid transparent;\n    border-right: 4px solid transparent;\n}\n.property[data-fold=\"1\"] .arrow:after {\n    border-top: 4px solid transparent;\n    border-bottom: 4px solid transparent;\n    border-right: 0;\n    border-left: 6px solid #eee;\n}\n.property[data-object=\"0\"] .arrow {\n    display: none;\n}\n.property.fold, .keyframes.fold, .value.fold {\n    display: none;\n}\n.property.select, .value.select, .keyframes.select {\n    background: rgba(120, 120, 120, 0.7);\n}\n.keyframes {\n\n}\n.keyframe_delay {\n  position: absolute;\n  top: 3px;\n  bottom: 3px;\n  left: 0;\n  background: #4af;\n  opacity: 0.2;\n  z-index: 0;\n}\n.keyframe_group {\n    position: absolute;\n    top: 3px;\n    bottom: 3px;\n    left: 0;\n    background: #4af;\n    opacity: 0.6;\n    border: 1px solid rgba(0, 0, 0, 0.2);\n    border-left-color: rgba(255, 255, 255, 0.2);\n    border-top-color: rgba(255, 255, 255, 0.2);\n    z-index: 0;\n}\n.keyframe_line {\n  position: absolute;\n  height: 8px;\n  top: 0;\n  bottom: 0;\n  margin: auto;\n  background: #666;\n  z-index: 0;\n}\n.keyframe {\n  position: absolute;\n  font-size: 0px;\n  width: 12px;\n  height: 12px;\n  top: 0px;\n  bottom: 0px;\n  margin: auto;\n  background: #fff;\n  border: 2px solid #383838;\n  border-radius: 2px;\n  box-sizing: border-box;\n  transform: translate(-50%) rotate(45deg);\n  z-index: 1;\n  cursor: pointer;\n}\n.keyframe[data-no=\"1\"] {\n    opacity: 0.2;\n}\n.select .keyframe {\n    border-color: #555;\n}\n.keyframe.select {\n    background: #4af;\n}\n.keyframes_container, .line_area {\n  position: relative;\n  width: calc(100% - 30px);\n  left: 15px;\n  height: 100%;\n}\n.line_area {\n  position: absolute;\n  top: 0;\n  z-index: 0;\n}\n.keyframe_cursor {\n  position: absolute;\n  top: 0;\n  z-index: 1;\n  background: #4af;\n  width: 1px;\n  height: 100%;\n  left: 15px;\n  transform: translate(-50%);\n}\n.scroll_aare .keyframe_cursor {\n  pointer-events: none;\n}\n.division_line {\n  position: absolute;\n  background: #333;\n  width: 1px;\n  height: 100%;\n  transform: translate(-50%);\n}\n`.replace(/\\.([^{,\\s\\d.]+)/g, `.${PREFIX}$1`);\n\nexport const DURATION = \"duration\";\nexport const FILL_MODE = \"fillMode\";\nexport const DIRECTION = \"direction\";\nexport const ITERATION_COUNT = \"iterationCount\";\nexport const DELAY = \"delay\";\nexport const EASING = \"easing\";\nexport const PLAY_SPEED = \"playSpeed\";\nexport const EASING_NAME = \"easingName\";\nexport const ITERATION_TIME = \"iterationTime\";\nexport const PAUSED = \"paused\";\nexport const ENDED = \"ended\";\nexport const TIMEUPDATE = \"timeupdate\";\nexport const ANIMATE = \"animate\";\nexport const PLAY = \"play\";\nexport const RUNNING = \"running\";\nexport const ITERATION = \"iteration\";\nexport const START_ANIMATION = \"startAnimation\";\nexport const PAUSE_ANIMATION = \"pauseAnimation\";\nexport const ALTERNATE = \"alternate\";\nexport const REVERSE = \"reverse\";\nexport const ALTERNATE_REVERSE = \"alternate-reverse\";\nexport const NORMAL = \"normal\";\nexport const INFINITE = \"infinite\";\nexport const PLAY_STATE = \"playState\";\nexport const PLAY_CSS = \"playCSS\";\nexport const PREV_TIME = \"prevTime\";\nexport const TICK_TIME = \"tickTime\";\nexport const CURRENT_TIME = \"currentTime\";\nexport const SELECTOR = \"selector\";\nexport const TRANSFORM_NAME = \"transform\";\n","import { PREFIX } from \"./consts\";\nimport Scene, { SceneItem, Frame } from \"scenejs\";\nimport {\n    hasClass as hasClass2,\n    addClass as addClass2,\n    removeClass as removeClass2,\n    IObject,\n    isObject,\n    isArray,\n    isUndefined,\n} from \"@daybrush/utils\";\nimport { ElementStructure, TimelineInfo } from \"./types\";\n\nexport function numberFormat(num: number, count: number, isRight?: boolean) {\n    const length = `${num}`.length;\n    const arr = [];\n\n    if (isRight) {\n        arr.push(num);\n    }\n    for (let i = length; i < count; ++i) {\n        arr.push(0);\n    }\n    if (!isRight) {\n        arr.push(num);\n    }\n    return arr.join(\"\");\n}\nexport function applyStyle(el: HTMLElement, style: IObject<any>) {\n    for (const name in style) {\n        el.style[name] = style[name];\n    }\n}\nexport function findIndex<T>(arr: T[], callback: (value: T, index: number, arr: T[]) => boolean) {\n    const length = arr.length;\n\n    for (let i = 0; i < length; ++i) {\n        if (callback(arr[i], i, arr)) {\n            return i;\n        }\n    }\n    return -1;\n}\nexport function find<T>(arr: T[], callback: (value: T, index: number, arr: T[]) => boolean): T | undefined {\n    return arr[findIndex(arr, callback)];\n}\nexport function findIndexByProperty(selectedProperty: string, structures: ElementStructure[]) {\n    return findIndex(\n        structures,\n        ({ dataset: { key } }) => key === selectedProperty,\n    );\n}\nexport function findStructureByProperty(selectedProperty: string, structures: ElementStructure[]) {\n    return find(\n        structures,\n        ({ dataset: { key } }) => key === selectedProperty,\n    );\n}\n\nexport function createElement(structure: ElementStructure) {\n    const { selector, dataset, attr, style, html } = structure;\n\n    const classNames = selector.match(/\\.([^.#\\s])+/g) || [];\n    const tag = (selector.match(/^[^.#\\s]+/g) || [])[0] || \"div\";\n    const id = (selector.match(/#[^.#\\s]+/g) || [])[0] || \"\";\n    const el = document.createElement(tag);\n\n    id && (el.id = id.replace(/^#/g, \"\"));\n    el.className = classNames.map(name => `${PREFIX}${name.replace(/^\\./g, \"\")}`).join(\" \");\n\n    if (dataset) {\n        for (const name in dataset) {\n            el.setAttribute(`data-${name}`, dataset[name]);\n        }\n    }\n    if (attr) {\n        for (const name in attr) {\n            el.setAttribute(name, attr[name]);\n        }\n    }\n    if (style) {\n        applyStyle(el, style);\n    }\n    if (html) {\n        el.innerHTML = html;\n    }\n    return el;\n}\nexport function updateElement(prevStructure: ElementStructure, nextStructure: ElementStructure) {\n    const { dataset, attr, style, html, element } = nextStructure;\n    if (dataset) {\n        for (const name in dataset) {\n            element.setAttribute(`data-${name}`, dataset[name]);\n        }\n    }\n    if (attr) {\n        for (const name in attr) {\n            element.setAttribute(name, attr[name]);\n        }\n    }\n    style && applyStyle(element, style);\n    if (prevStructure.html !== nextStructure.html) {\n        element.innerHTML = html;\n    }\n}\nexport function keys(value: object) {\n    const arr = [];\n    for (const name in value) {\n        arr.push(name);\n    }\n    return arr;\n}\nexport function toValue(value: any) {\n    const type = typeof value;\n    if (type === \"object\") {\n        if (Array.isArray(value)) {\n            return `[${value.join(\", \")}]`;\n        }\n        return `{${keys(value).map(k => `${k}: ${toValue(value[k])}`).join(\", \")}}`;\n    }\n    return value;\n}\nexport function flatObject(obj: IObject<any>, newObj: IObject<any> = {}) {\n\n    for (const name in obj) {\n        const value = obj[name];\n\n        if (isObject(value)) {\n            const nextObj = flatObject(isFrame(value) ? value.get() : value);\n\n            for (const nextName in nextObj) {\n                newObj[`${name}///${nextName}`] = nextObj[nextName];\n            }\n        } else {\n            newObj[name] = value;\n        }\n    }\n    return newObj;\n}\n\nexport function getTarget<T extends HTMLElement>(target: T, conditionCallback: (el: Element) => boolean): T {\n    let parentTarget = target;\n\n    while (parentTarget && parentTarget !== document.body) {\n        if (conditionCallback(parentTarget)) {\n            return parentTarget;\n        }\n        parentTarget = parentTarget.parentNode as T;\n    }\n    return null;\n}\n\nexport function hasClass(target: Element, className: string) {\n    return hasClass2(target, `${PREFIX}${className}`);\n}\nexport function addClass(target: Element, className: string) {\n    return addClass2(target, `${PREFIX}${className}`);\n}\nexport function removeClass(target: Element, className: string) {\n    return removeClass2(target, `${PREFIX}${className}`);\n}\nexport function findStructure(\n    selector: string,\n    structure: ElementStructure | ElementStructure[],\n    multi: true,\n    arr?: ElementStructure[],\n): ElementStructure[];\nexport function findStructure(\n    selector: string,\n    structure: ElementStructure | ElementStructure[],\n    multi?: false,\n    arr?: ElementStructure[],\n): ElementStructure;\nexport function findStructure(\n    selector: string,\n    structure: ElementStructure | ElementStructure[],\n    multi: true | false,\n    arr?: ElementStructure[],\n): ElementStructure | ElementStructure[];\nexport function findStructure(\n    selector: string,\n    structure: ElementStructure | ElementStructure[],\n    multi: boolean = false,\n    arr: ElementStructure[] = [],\n): ElementStructure | ElementStructure[] {\n    if (isArray(structure)) {\n        const length = structure.length;\n\n        for (let i = 0; i < length; ++i) {\n            findStructure(selector, structure[i], multi, arr);\n        }\n    } else {\n        if (structure.selector === selector) {\n            arr.push(structure);\n        }\n        if (!multi && arr.length) {\n            return arr[0];\n        }\n        if (structure.children) {\n            findStructure(selector, structure.children, multi, arr);\n        }\n    }\n    return multi ? arr : arr[0];\n}\nexport function isScene(value: any): value is Scene {\n    return !!(value.constructor as typeof Scene).prototype.getItem;\n}\nexport function isSceneItem(value: any): value is SceneItem {\n    return !!(value.constructor as typeof SceneItem).prototype.getFrame;\n}\nexport function isFrame(value: any): value is Frame {\n    return !!(value.constructor as typeof Frame).prototype.toCSS;\n}\nexport function splitProperty(scene: Scene, property: string) {\n    const names = property.split(\"///\");\n    const length = names.length;\n    let item: Scene | SceneItem = scene;\n    let i;\n\n    for (i = 0; i < length; ++i) {\n        if (isSceneItem(item)) {\n            break;\n        }\n        item = scene.getItem(names[i]);\n    }\n    return {\n        item: item as SceneItem,\n        names: names.slice(0, i),\n        properties: names.slice(i),\n    };\n}\nexport function getSceneItem(scene: Scene, names: string[]): SceneItem {\n    return names.reduce<any>(\n        (nextScene, name) => nextScene.getItem(name),\n        scene,\n    );\n}\n\nexport function findElementIndexByPosition(elements: HTMLElement[], pos: number): number {\n    const length = elements.length;\n\n    for (let index = 0; index < length; ++index) {\n        const el = elements[index];\n        const box = el.getBoundingClientRect();\n        const top = box.top;\n        const bottom = top + box.height;\n\n        if (top <= pos && pos < bottom) {\n            return index;\n        }\n    }\n    return -1;\n}\n","import { now } from \"@daybrush/utils\";\n\nlet prevTime = 0;\nlet prevX = -1;\nlet prevY = -1;\n\nexport function dblCheck(\n    isDrag: boolean,\n    e: any,\n    clientX: number,\n    clientY: number,\n    callback: (e: any, clientX: number, clientY: number) => void,\n) {\n    const currentTime = now();\n\n    if (!isDrag) {\n        if (\n            prevX === clientX &&\n            prevY === clientY &&\n            currentTime - prevTime <= 500\n        ) {\n            callback(e, clientX, clientY);\n        }\n        prevX = clientX;\n        prevY = clientY;\n        prevTime = currentTime;\n    }\n}\n","import { getKeytimesStructure } from \"./KeytimesStructure\";\nimport { Ids, ElementStructure } from \"./types\";\n\nexport function getHeaderAreaStructure(ids: Ids, zoom: number, maxDuration: number, maxTime: number): ElementStructure {\n    return {\n        selector: \".header_area\",\n        ref: e => {\n            ids.keyframesScrollAreas = [];\n            ids.keyframesAreas = [];\n            ids.propertiesAreas = [];\n        },\n        children: [\n            {\n                ref: (e: ElementStructure) => {\n                    ids.propertiesAreas[0] = e;\n                },\n                selector: \".properties_area\",\n                children: [\n                    {\n                        selector: \".property\",\n                        html: \"Name\",\n                    },\n                ],\n            },\n            {\n                selector: \".values_area\",\n                children: {\n                    selector: \".value\",\n                    children: {\n                        key: \"add\",\n                        selector: \".add\",\n                        html: \"+\",\n                        ref: (e: ElementStructure) => {\n                            ids.addItem = e;\n                        },\n                    },\n                },\n            },\n            getKeytimesAreaStructure(ids, zoom, maxDuration, maxTime),\n        ],\n    };\n}\n\nexport function getKeytimesAreaStructure(\n    ids: Ids,\n    zoom: number,\n    maxDuration: number,\n    maxTime: number,\n): ElementStructure {\n    return {\n        ref: e => {\n            ids.keyframesAreas[0] = e;\n        },\n        selector: \".keyframes_area\",\n        children: {\n            style: {\n                minWidth: `${50 * maxTime}px`,\n                width: `${Math.min(maxDuration ? maxTime / maxDuration : 1, 2) * zoom * 100}%`,\n            },\n            dataset: {\n                width: Math.min(maxDuration ? maxTime / maxDuration : 1, 2),\n            },\n            ref: (e: ElementStructure) => {\n                ids.keyframesScrollAreas[0] = e;\n            },\n            selector: \".keyframes_scroll_area\",\n            children: {\n                ref: e => {\n                    ids.cursors = [];\n                },\n                selector: \".keyframes\",\n                children: [\n                    {\n                        ref: e => {\n                            ids.keytimesContainer = e;\n                        },\n                        selector: \".keyframes_container\",\n                        children: getKeytimesStructure(maxTime),\n                    },\n                    {\n                        selector: \".keyframe_cursor\",\n                        ref: e => {\n                            ids.cursors[0] = e;\n                        },\n                    },\n                ],\n            },\n        },\n    };\n}\n","export function getKeytimesStructure(maxTime: number) {\n    const keytimes = [];\n\n    for (let time = 0; time <= maxTime; ++time) {\n        keytimes.push({\n            key: time,\n            dataset: {\n                time,\n            },\n            selector: \".keytime\",\n            style: {\n                width: `${100 / maxTime}%`,\n            },\n            children: [\n                {\n                    selector: \"span\",\n                    html: `${time}`,\n                },\n                {selector: \".graduation.start\"},\n                {selector: \".graduation.quarter\"},\n                {selector: \".graduation.half\"},\n                {selector: \".graduation.quarter3\"},\n            ],\n        });\n    }\n    return keytimes;\n}\nexport function getLinesStructure(maxTime: number) {\n    const lines = [];\n\n    for (let time = 0; time <= maxTime; ++time) {\n        lines.push({\n            key: time,\n            selector: \".division_line\",\n            style: {\n                left: `${100 / maxTime * time}%`,\n            },\n        });\n    }\n    return lines;\n}\n","import { toValue, applyStyle, isScene, findIndex } from \"./utils\";\nimport { ElementStructure, Ids, TimelineInfo, PropertiesInfo } from \"./types\";\nimport { getLinesStructure } from \"./KeytimesStructure\";\nimport { isUndefined } from \"@daybrush/utils\";\n\nexport function updateKeyframesStructure(keyframes: ElementStructure[], maxTime: number) {\n    keyframes.forEach(keyframe => {\n        const { selector, dataset, style, element } = keyframe;\n        if (selector === \".keyframe\") {\n            style.left = `${dataset.time / maxTime * 100}%`;\n        } else {\n            style.left = `${dataset.from / maxTime * 100}%`,\n                style.width = `${(dataset.to - dataset.from) / maxTime * 100}%`;\n        }\n        applyStyle(element, style);\n    });\n}\n\nexport function getKeyframesAreaStructure(\n    ids: Ids,\n    keyframesList: ElementStructure[],\n    zoom: number,\n    maxDuration: number,\n    maxTime: number,\n): ElementStructure {\n    const width = Math.min(maxDuration ? maxTime / maxDuration : 1, 2);\n    return {\n        ref: e => {\n            ids.keyframesAreas[1] = e;\n        },\n        selector: \".keyframes_area\",\n        children: {\n            style: {\n                minWidth: `${50 * maxTime}px`,\n                width: `${width * zoom * 100}%`,\n            },\n            dataset: {\n                width,\n            },\n            ref: e => {\n                ids.keyframesScrollAreas[1] = e;\n            },\n            selector: \".keyframes_scroll_area\",\n            children: getKeyframesScrollAreaChildrenStructure(ids, keyframesList, maxTime),\n        },\n    };\n}\nexport function getKeyframesScrollAreaChildrenStructure(\n    ids: Ids,\n    keyframesList: ElementStructure[],\n    maxTime: number,\n): ElementStructure[] {\n    return [\n        ...keyframesList,\n        {\n            key: \"cursor\",\n            selector: \".keyframe_cursor\",\n            ref: e => {\n                ids.cursors[1] = e;\n            },\n        },\n        {\n            key: \"lineArea\",\n            ref: e => {\n                ids.lineArea = e;\n            },\n            selector: \".line_area\",\n            children: getLinesStructure(maxTime),\n        },\n    ];\n}\nexport function getKeyframesListStructure(\n    ids: Ids,\n    timelineInfo: TimelineInfo,\n    maxTime: number,\n): ElementStructure[] {\n    const keyframesList: ElementStructure[] = [];\n\n    for (const key in timelineInfo) {\n        const propertiesInfo = timelineInfo[key];\n        const keyframes = getKeyframesStructure(propertiesInfo, maxTime);\n\n        keyframesList.push({\n            ref: (e, i) => {\n                ids.keyframesList[i] = e;\n                ids.keyframesContainers[i] = e.children as ElementStructure;\n            },\n            selector: \".keyframes\",\n            key,\n            dataset: {\n                item: propertiesInfo.isItem ? \"1\" : \"0\",\n                key,\n            },\n            datas: propertiesInfo,\n            children: {\n                selector: \".keyframes_container\",\n                children: keyframes,\n            },\n        });\n    }\n    return keyframesList;\n}\nexport function getDelayFrameStructure(\n    time: number,\n    nextTime: number,\n    maxTime: number,\n): ElementStructure {\n    return {\n        selector: \".keyframe_delay\",\n        key: `delay${time},${nextTime}`,\n        datas: {\n            time: -1,\n        },\n        style: {\n            left: `${time / maxTime * 100}%`,\n            width: `${(nextTime - time) / maxTime * 100}%`,\n        },\n    };\n}\nexport function getKeyframesStructure(\n    propertiesInfo: PropertiesInfo,\n    maxTime: number,\n): ElementStructure[] {\n    const { item, frames, properties } = propertiesInfo;\n    const isItScene = isScene(item);\n    const duration = item.getDuration();\n\n    const keyframes: ElementStructure[] = [];\n    const keyframeGroups: ElementStructure[] = [];\n    const delayFrames: ElementStructure[] = [];\n    const keyframeLines: ElementStructure[] = [];\n\n    const length = frames.length;\n    const hasProperties = properties.length;\n\n    let startIndex = 0;\n    if (length >= 2 && !hasProperties) {\n        const index = findIndex(frames, ([, , value]) => !isUndefined(value));\n        startIndex = Math.max(frames[0][1] === 0 && frames[1][1] === 0 ? 1 : 0, index);\n        const startFrame = frames[startIndex];\n        const endFrame = frames[length - 1];\n        const time = startFrame[0];\n        const nextTime = endFrame[0];\n\n        keyframeGroups.push({\n            selector: \".keyframe_group\",\n            key: `group`,\n            datas: {\n                time: `${time},${nextTime}`,\n                from: time,\n                to: nextTime,\n            },\n            dataset: {\n                time,\n            },\n            style: {\n                left: `${time / maxTime * 100}%`,\n                width: `${(nextTime - time) / maxTime * 100}%`,\n            },\n        });\n    }\n    frames.forEach(([time, iterationTime, value], i): ElementStructure => {\n        const valueText = toValue(value);\n        if (frames[i + 1]) {\n            const [nextTime, nextIterationTime] = frames[i + 1];\n\n            if (\n                (iterationTime === 0 && nextIterationTime === 0)\n                || (iterationTime === duration && nextIterationTime === duration)\n            ) {\n                delayFrames.push(getDelayFrameStructure(time, nextTime, maxTime));\n            }\n        }\n        if (\n            i === 0\n            && time === 0\n            && iterationTime === 0\n            && isUndefined(value)\n            && !hasProperties\n        ) {\n            return;\n        }\n        if (frames[i + 1]) {\n            const [nextTime, , nextValue] = frames[i + 1];\n            const nextValueText = toValue(nextValue);\n\n            if (\n                !isItScene\n                && !isUndefined(value)\n                && !isUndefined(nextValue)\n                && valueText !== nextValueText\n                && hasProperties\n            ) {\n                keyframeLines.push({\n                    selector: \".keyframe_line\",\n                    key: `line${keyframeLines.length}`,\n                    datas: {\n                        time: `${time},${nextTime}`,\n                        from: time,\n                        to: nextTime,\n                    },\n                    style: {\n                        left: `${time / maxTime * 100}%`,\n                        width: `${(nextTime - time) / maxTime * 100}%`,\n                    },\n                });\n            }\n        }\n\n        if (isItScene || i < startIndex) {\n            return;\n        }\n        keyframes.push({\n            key: `keyframe${i}`,\n            selector: \".keyframe\",\n            dataset: {\n                time,\n            },\n            datas: {\n                time,\n                iterationTime,\n                value: valueText,\n            },\n            style: {\n                left: `${time / maxTime * 100}%`,\n            },\n            html: `${time} ${valueText}`,\n        });\n    });\n\n    return [...keyframeGroups, ...keyframes, ...delayFrames, ...keyframeLines];\n}\n","import { getKeyframesAreaStructure, getKeyframesListStructure } from \"./KeyframesStructure\";\nimport { ElementStructure, Ids, TimelineInfo } from \"./types\";\nimport { getPropertiesStructure } from \"./PropertiesStructure\";\nimport { getValuesStructure } from \"./ValuesStructure\";\n\nexport function getScrollAreaStructure(\n    ids: Ids,\n    timelineInfo: TimelineInfo,\n    zoom: number,\n    maxDuration: number,\n    maxTime: number,\n): ElementStructure {\n    const keyframesList: ElementStructure[] = getKeyframesListStructure(ids, timelineInfo, maxTime);\n\n    return {\n        ref: e => {\n            ids.scrollArea = e;\n            ids.keyframesList = [];\n            ids.keyframesContainers = [];\n        },\n        selector: \".scroll_area\",\n        children: [\n            {\n                ref: e => {\n                    ids.propertiesAreas[1] = e;\n                    ids.properties = [];\n                },\n                selector: \".properties_area\",\n                children: [\n                    {\n                        selector: \".properties_scroll_area\",\n                        children: getPropertiesStructure(ids, timelineInfo),\n                    },\n                ],\n            },\n            {\n                ref: e => {\n                    ids.valuesArea = e;\n                    ids.values = [];\n                },\n                selector: \".values_area\",\n                children: getValuesStructure(ids, timelineInfo),\n            },\n            getKeyframesAreaStructure(ids, keyframesList, zoom, maxDuration, maxTime),\n        ],\n    };\n}\n","import { ElementStructure, Ids, TimelineInfo } from \"./types\";\n\nexport function getPropertiesStructure(ids: Ids, timelineInfo: TimelineInfo) {\n    const properties: ElementStructure[] = [];\n\n    for (const key in timelineInfo) {\n        const propertiesInfo = timelineInfo[key];\n        const propertyNames = propertiesInfo.keys;\n        const length = propertyNames.length;\n        const id = propertyNames[length - 1];\n\n        properties.push({\n            ref: (e, i) => {\n                ids.properties[i] = e;\n            },\n            key,\n            selector: \".property\",\n            dataset: {\n                key,\n                object: propertiesInfo.isParent ? \"1\" : \"0\",\n                item: propertiesInfo.isItem ? \"1\" : \"0\",\n            },\n            datas: propertiesInfo,\n            style: {\n                paddingLeft: `${10 + (length - 1) * 20}px`,\n            },\n            children: [\n                { selector: \".arrow\" },\n                {\n                    selector: \"span\",\n                    html: id,\n                },\n                { selector: \".remove\" },\n            ],\n        });\n    }\n    return properties;\n}\n","import { isObject } from \"@daybrush/utils\";\nimport { Ids, ElementStructure, TimelineInfo } from \"./types\";\n\nexport function getValuesStructure(ids: Ids, timelineInfo: TimelineInfo): ElementStructure[] {\n    const values: ElementStructure[] = [];\n\n    for (const key in timelineInfo) {\n        const propertiesInfo = timelineInfo[key];\n        const frames = propertiesInfo.frames;\n        values.push({\n            ref: (e, i) => {\n                ids.values[i] = e;\n            },\n            key,\n            selector: \".value\",\n            dataset: {\n                key,\n                item: propertiesInfo.isItem ? \"1\" : \"0\",\n                object: propertiesInfo.isParent ? \"1\" : \"0\",\n            },\n            datas: propertiesInfo,\n            children: propertiesInfo.isParent\n            ? {\n                key: \"add\",\n                selector: \".add\",\n                html: \"+\",\n            }\n            : {\n                key: \"input\",\n                selector: \"input\",\n                attr: {\n                    value: frames[0] ? frames[0][1] : \"\",\n                },\n            },\n        });\n    }\n    return values;\n}\n","import Scene, { AnimatorState, SceneItem } from \"scenejs\";\nimport { ITERATION_COUNT, DELAY, PLAY_SPEED, DIRECTION, REVERSE, ALTERNATE, ALTERNATE_REVERSE } from \"./consts\";\nimport { TimelineInfo } from \"./types\";\nimport { isScene } from \"./utils\";\nimport { isUndefined, isObject } from \"@daybrush/utils\";\n\nexport const MAXIMUM = 1000000;\nexport function toFixed(num: number) {\n    return Math.round(num * MAXIMUM) / MAXIMUM;\n}\nexport function addEntry(entries: number[][], time: number, keytime: number) {\n    const prevEntry = entries[entries.length - 1];\n\n    (!prevEntry || prevEntry[0] !== time || prevEntry[1] !== keytime) &&\n        entries.push([toFixed(time), toFixed(keytime)]);\n}\nexport function dotNumber(a1: number, a2: number, b1: number, b2: number) {\n    return (a1 * b2 + a2 * b1) / (b1 + b2);\n  }\nexport function getEntries(times: number[], states: AnimatorState[]) {\n    if (!times.length) {\n        return [];\n    }\n    let entries = times.map(time => ([time, time]));\n    let nextEntries = [];\n    const firstEntry = entries[0];\n    if (firstEntry[0] !== 0 && states[states.length - 1][DELAY]) {\n        entries.unshift([0, 0]);\n    }\n\n    states.forEach(state => {\n        const iterationCount = state[ITERATION_COUNT] as number;\n        const delay = state[DELAY];\n        const playSpeed = state[PLAY_SPEED];\n        const direction = state[DIRECTION];\n        const intCount = Math.ceil(iterationCount);\n        const currentDuration = entries[entries.length - 1][0];\n        const length = entries.length;\n        const lastTime = currentDuration * iterationCount;\n\n        for (let i = 0; i < intCount; ++i) {\n            const isReverse =\n                direction === REVERSE ||\n                direction === ALTERNATE && i % 2 ||\n                direction === ALTERNATE_REVERSE && !(i % 2);\n\n            for (let j = 0; j < length; ++j) {\n                const entry = entries[isReverse ? length - j - 1 : j];\n                const time = entry[1];\n                const currentTime = currentDuration * i + (isReverse ? currentDuration - entry[0] : entry[0]);\n                const prevEntry = entries[isReverse ? length - j : j - 1];\n\n                if (currentTime > lastTime) {\n                    if (j !== 0) {\n                        const prevTime = currentDuration * i +\n                            (isReverse ? currentDuration - prevEntry[0] : prevEntry[0]);\n                        const divideTime = dotNumber(prevEntry[1], time, lastTime - prevTime, currentTime - lastTime);\n\n                        addEntry(nextEntries, (delay + currentDuration * iterationCount) / playSpeed, divideTime);\n                    }\n                    break;\n                } else if (\n                    currentTime === lastTime\n                    && nextEntries.length\n                    && nextEntries[nextEntries.length - 1][0] === lastTime + delay\n                ) {\n                    break;\n                }\n                addEntry(nextEntries, (delay + currentTime) / playSpeed, time);\n            }\n        }\n        // delay time\n        delay && nextEntries.unshift([0, nextEntries[0][1]]);\n\n        entries = nextEntries;\n        nextEntries = [];\n    });\n\n    return entries;\n}\nexport function getItemInfo(\n    timelineInfo: TimelineInfo,\n    items: Array<Scene | SceneItem>,\n    names: Array<string | number>,\n    item: SceneItem) {\n    item.update();\n    const times = item.times.slice();\n\n    const originalDuration = item.getDuration();\n    (!item.getFrame(0)) && times.unshift(0);\n    (!item.getFrame(originalDuration)) && times.push(originalDuration);\n    const states = items.slice(1).map(animator => animator.state).reverse();\n    const entries = getEntries(times, states);\n    const parentItem = items[items.length - 2] as Scene;\n\n    (function getPropertyInfo(itemNames: any, ...properties: any[]) {\n        const frames = [];\n        const isParent = isObject(itemNames);\n        const isItem = properties.length === 0;\n        entries.forEach(([time, iterationTime]) => {\n            const value = item.get(iterationTime, ...properties);\n            if (isUndefined(value) && properties.length) {\n                return;\n            }\n            frames.push([time, iterationTime, value]);\n        });\n        const keys = [...names, ...properties];\n        const key = keys.join(\"///\");\n\n        if (key) {\n            timelineInfo[key] = {\n                key,\n                keys,\n                parentItem,\n                isParent,\n                isItem,\n                item,\n                names,\n                properties,\n                frames,\n            };\n        }\n        if (isParent) {\n            for (const property in itemNames) {\n                getPropertyInfo(itemNames[property], ...properties, property);\n            }\n        }\n    })(item.names);\n}\nexport function getTimelineInfo(scene: Scene | SceneItem): TimelineInfo {\n    const timelineInfo: TimelineInfo = {};\n    (function sceneForEach(...items: Array<Scene | SceneItem>) {\n        const length = items.length;\n        const lastItem = items[length - 1];\n        const names = items.slice(1).map(item => item.getId());\n        if (isScene(lastItem)) {\n            if (names.length) {\n                const key = names.join(\"///\");\n\n                const times = [0, lastItem.getDuration()];\n                const entries = getEntries(times, items.slice(1).map(animator => animator.state).reverse());\n                const frames = [];\n                entries.forEach(([time, iterationTime]) => {\n                    frames.push([time, iterationTime, iterationTime]);\n                });\n                timelineInfo[key] = {\n                    key,\n                    keys: names,\n                    isItem: true,\n                    isParent: true,\n                    parentItem: items[length - 2] as Scene,\n                    item: lastItem,\n                    names: [],\n                    properties: [],\n                    frames,\n                };\n            }\n            lastItem.forEach((item: Scene | SceneItem) => {\n                sceneForEach(...items, item);\n            });\n        } else {\n            getItemInfo(timelineInfo, items, names, lastItem);\n        }\n    })(scene);\n    return timelineInfo;\n}\n","import Scene, { SceneItem } from \"scenejs\";\nimport {\n    getTarget,\n    hasClass, removeClass, addClass,\n    flatObject, splitProperty, findElementIndexByPosition,\n    createElement, updateElement, findIndexByProperty, findStructure, numberFormat, isScene, findStructureByProperty,\n} from \"./utils\";\nimport { drag } from \"@daybrush/drag\";\nimport { CSS, SUPPORT_TOUCH, SUPPORT_POINTER_EVENTS } from \"./consts\";\nimport { IObject, addEvent, isUndefined } from \"@daybrush/utils\";\nimport Axes, { PinchInput } from \"@egjs/axes\";\nimport { ElementStructure, Ids, PropertiesInfo, TimelineInfo } from \"./types\";\nimport { dblCheck } from \"./dblcheck\";\nimport KeyController from \"keycon\";\nimport DataDOM from \"data-dom\";\nimport { getHeaderAreaStructure, getKeytimesAreaStructure } from \"./HeaderAreaStructure\";\nimport { getScrollAreaStructure } from \"./ScrollAreaStructure\";\nimport { getControlAreaStructure } from \"./ControlAreaStructure\";\nimport Component from \"@egjs/component\";\nimport { getTimelineInfo } from \"./TimelineInfo\";\nimport { Info } from \"./Info\";\n\nlet isExportCSS = false;\n\nexport default class Timeline extends Component {\n    public scene: Scene | SceneItem;\n    public options: {\n        keyboard?: boolean,\n    };\n    private maxTime: number = 0;\n    private axes: Axes;\n    private selectedProperty: string = \"\";\n    private selectedTime: number = -1;\n    private keycon: KeyController;\n    private datadom: DataDOM<ElementStructure>;\n    private structure: ElementStructure;\n    private ids: Ids = {};\n    private timelineInfo: TimelineInfo;\n    constructor(scene: Scene | SceneItem, parentEl: HTMLElement, options: {\n        keyboard?: boolean,\n    } = {}) {\n        super();\n        this.options = {\n            keyboard: true,\n            ...options,\n        };\n        scene.finish();\n        this.scene = scene;\n        this.initStructure(scene, parentEl);\n        this.initEditor();\n        this.initScroll();\n        this.initWheelZoom();\n        this.initDragKeyframes();\n        this.initClickProperty();\n        this.initController();\n        this.initDragValues();\n        this.initKeyController();\n\n        this.setTime(0);\n\n        // new Info(this, parentEl);\n    }\n    public getElement() {\n        return this.structure.element;\n    }\n    // scene control\n    public prev() {\n        this.setTime(this.scene.getTime() - 0.05);\n    }\n    public next() {\n        this.setTime(this.scene.getTime() + 0.05);\n    }\n    public finish() {\n        this.scene.finish();\n    }\n    public togglePlay() {\n        const scene = this.scene;\n        if (scene.getPlayState() === \"running\") {\n            scene.pause();\n        } else {\n            scene.play();\n        }\n    }\n    public setTime(time: number) {\n        const scene = this.scene;\n        const direction = scene.getDirection();\n\n        scene.pause();\n\n        if (direction === \"normal\" || direction === \"alternate\") {\n            scene.setTime(time);\n        } else {\n            scene.setTime(scene.getDuration() - time);\n        }\n    }\n    public update() {\n        const scene = this.scene;\n        this.timelineInfo = getTimelineInfo(scene);\n        const maxDuration = Math.ceil(scene.getDuration());\n        const maxTime = Math.max(this.maxTime, maxDuration);\n        let zoom = this.axes.get([\"zoom\"]).zoom;\n        const currentMaxTime = this.maxTime;\n        this.maxTime = maxTime;\n        const ids = this.ids;\n        const prevKeytimesArea = ids.keyframesAreas[0];\n        const nextZoom = currentMaxTime > 1 ? maxTime / currentMaxTime : 1;\n\n        zoom = Math.max(1, zoom * nextZoom);\n        this.axes.axm.set({ zoom });\n        // update keytimes\n        this.datadom.update(\n            prevKeytimesArea,\n            getKeytimesAreaStructure(ids, zoom, maxTime, maxTime),\n        );\n\n        const nextScrollAreaStructure = getScrollAreaStructure(\n            ids,\n            this.timelineInfo,\n            this.axes.get([\"zoom\"]).zoom,\n            maxTime, maxTime,\n        );\n\n        this.datadom.update(\n            ids.scrollArea,\n            nextScrollAreaStructure,\n        );\n        this.setTime(scene.getTime());\n    }\n    private newItem(scene: Scene) {\n        const name = prompt(\"Add Item\");\n\n        if (!name) {\n            return;\n        }\n        (this.scene as Scene).newItem(name);\n        this.update();\n    }\n    private newProperty(item: SceneItem, properties: string[]) {\n        const property = prompt(\"new property\");\n\n        if (!property) {\n            return;\n        }\n        item.set(item.getIterationTime(), ...properties, property, 0);\n        this.update();\n    }\n    // init\n    private initController() {\n        const ids = this.ids;\n        const playBtn = this.ids.playBtn.element;\n        const scene = this.scene;\n\n        this.ids.addItem.element.addEventListener(\"click\", e => {\n            if (isScene(this.scene)) {\n                this.newItem(this.scene);\n            } else {\n                this.newProperty(this.scene, []);\n            }\n        });\n        playBtn.addEventListener(\"click\", e => {\n            this.togglePlay();\n            e.preventDefault();\n        });\n        ids.unselectedArea.element.addEventListener(\"click\", e => {\n            this.select(\"\", -1);\n        });\n        ids.prevBtn.element.addEventListener(\"click\", e => {\n            this.prev();\n            e.preventDefault();\n        });\n        ids.nextBtn.element.addEventListener(\"click\", e => {\n            this.next();\n            e.preventDefault();\n        });\n        scene.on(\"play\", () => {\n            addClass(playBtn, \"pause\");\n            removeClass(playBtn, \"play\");\n            // playBtn.innerHTML = \"pause\";\n        });\n        scene.on(\"paused\", () => {\n            addClass(playBtn, \"play\");\n            removeClass(playBtn, \"pause\");\n            // playBtn.innerHTML = \"play\";\n        });\n        if (this.options.keyboard) {\n            new KeyController(ids.timeArea.element)\n            .keydown(e => {\n                !e.isToggle && e.inputEvent.stopPropagation();\n            })\n            .keyup(e => {\n                !e.isToggle && e.inputEvent.stopPropagation();\n            })\n            .keyup(\"enter\", e => {\n                // go to time\n                const element = ids.timeArea.element;\n                const value = (element as HTMLInputElement).value;\n                const result = /(\\d+):(\\d+):(\\d+)/g.exec(value);\n\n                if (!result) {\n                    return;\n                }\n                const minute = parseFloat(result[1]);\n                const second = parseFloat(result[2]);\n                const milisecond = parseFloat(`0.${result[3]}`);\n                const time = minute * 60 + second + milisecond;\n\n                this.setTime(time);\n            });\n        }\n    }\n    private initKeyController() {\n        const ids = this.ids;\n\n        window.addEventListener(\"blur\", () => {\n            removeClass(ids.timeline.element, \"alt\");\n        });\n\n        this.keycon = new KeyController()\n        .keydown(\"alt\", () => {\n            addClass(ids.timeline.element, \"alt\");\n        })\n        .keyup(\"alt\", () => {\n            removeClass(ids.timeline.element, \"alt\");\n        });\n\n        if (this.options.keyboard) {\n            this.keycon.keydown(\"space\", ({inputEvent}) => {\n                inputEvent.preventDefault();\n            })\n            .keydown(\"left\", e => {\n                this.prev();\n            })\n            .keydown(\"right\", e => {\n                this.next();\n            })\n            .keyup(\"backspace\", () => {\n                this.removeKeyframe(this.selectedProperty);\n            })\n            .keyup(\"esc\", () => {\n                this.finish();\n            })\n            .keyup(\"space\", () => {\n                this.togglePlay();\n            });\n        }\n    }\n    private initStructure(scene: Scene | SceneItem, parentEl: HTMLElement) {\n        this.timelineInfo = getTimelineInfo(scene);\n        const duration = Math.ceil(scene.getDuration());\n        const maxDuration = Math.ceil(duration);\n        const maxTime = maxDuration;\n        const ids = this.ids;\n        let timelineCSS: ElementStructure;\n\n        this.maxTime = maxTime;\n        if (!isExportCSS) {\n            timelineCSS = {\n                selector: \"style.style\",\n                html: CSS,\n            };\n            isExportCSS = true;\n        }\n\n        const structure: ElementStructure = {\n            selector: \".timeline\",\n            ref: e => {\n                ids.timeline = e;\n            },\n            children: [\n                timelineCSS,\n                getControlAreaStructure(ids),\n                getHeaderAreaStructure(ids, 1, maxDuration, maxTime),\n                getScrollAreaStructure(ids, this.timelineInfo, 1, maxDuration, maxTime),\n            ],\n        };\n        this.datadom = new DataDOM(\n            createElement,\n            updateElement,\n        );\n        this.structure = this.datadom.render(structure, parentEl);\n\n        // fold all\n        this.ids.properties.forEach((property, i) => {\n            const propertiesInfo = property.datas as PropertiesInfo;\n            const {keys, isParent} = propertiesInfo;\n            if (keys.length === 1 && isParent) {\n                this.fold(i);\n            }\n        });\n    }\n    private initScroll() {\n        const {\n            keyframesAreas,\n        } = this.ids;\n        let isScrollKeyframe = false;\n\n        const headerKeyframesArea = keyframesAreas[0].element;\n        const scrollKeyframesArea = keyframesAreas[1].element;\n        headerKeyframesArea.addEventListener(\"scroll\", () => {\n            if (isScrollKeyframe) {\n                isScrollKeyframe = false;\n            } else {\n                isScrollKeyframe = true;\n                scrollKeyframesArea.scrollLeft = headerKeyframesArea.scrollLeft;\n            }\n        });\n        scrollKeyframesArea.addEventListener(\"scroll\", () => {\n            if (isScrollKeyframe) {\n                isScrollKeyframe = false;\n            } else {\n                isScrollKeyframe = true;\n                headerKeyframesArea.scrollLeft = scrollKeyframesArea.scrollLeft;\n            }\n        });\n    }\n    private initWheelZoom() {\n        const ids = this.ids;\n        const keyframesScrollAreas = ids.keyframesScrollAreas;\n        const headerArea = keyframesScrollAreas[0].element;\n        const scrollArea = keyframesScrollAreas[1].element;\n\n        const axes = new Axes(\n            {\n                zoom: {\n                    range: [1, Infinity],\n                },\n            },\n            {},\n            { zoom: 1 },\n        );\n\n        if (SUPPORT_TOUCH || SUPPORT_POINTER_EVENTS) {\n            axes.connect(\"zoom\", new PinchInput(scrollArea, {\n                scale: 0.1,\n                hammerManagerOptions: {\n                    touchAction: \"auto\",\n                },\n            }));\n        }\n        axes.on(\"hold\", e => {\n            if (e.inputEvent) {\n                e.inputEvent.preventDefault();\n            }\n        });\n        axes.on(\"change\", e => {\n            const scale = ids.keyframesScrollAreas[0].dataset.width;\n            const width = e.pos.zoom * scale * 100;\n\n            ids.keyframesScrollAreas.forEach(({ element }) => {\n                element.style.width = `${width}%`;\n            });\n\n            if (e.inputEvent) {\n                e.inputEvent.preventDefault();\n            }\n        });\n\n        this.axes = axes;\n        headerArea.addEventListener(\"wheel\", e => {\n            const delta = e.deltaY;\n\n            axes.setBy({ zoom: delta / 5000 });\n            !e.deltaX && e.preventDefault();\n        });\n\n        addEvent(scrollArea, \"wheel\", e => {\n            if (!this.keycon.altKey) {\n                return;\n            }\n            e.preventDefault();\n            const delta = e.deltaY;\n\n            axes.setBy({ zoom: delta / 5000 });\n        });\n    }\n    private select(selectedProperty: string, keyframeTime?: number) {\n        const prevSelectedProperty = this.selectedProperty;\n        const prevSelectedTime = this.selectedTime;\n        const ids = this.ids;\n        const values = ids.values;\n        const properties = ids.properties;\n        const keyframesList = ids.keyframesList;\n\n        this.selectedProperty = selectedProperty;\n        this.scene.pause();\n        if (prevSelectedProperty) {\n            const prevSelectedIndex = findIndexByProperty(prevSelectedProperty, properties);\n\n            removeClass(properties[prevSelectedIndex].element, \"select\");\n            removeClass(values[prevSelectedIndex].element, \"select\");\n            removeClass(keyframesList[prevSelectedIndex].element, \"select\");\n\n            if (prevSelectedTime >= 0) {\n                const keyframes = ids.keyframesContainers[prevSelectedIndex].children as ElementStructure[];\n\n                keyframes.forEach(keyframe => {\n                    if (keyframe.datas.time === prevSelectedTime) {\n                        removeClass(keyframe.element, \"select\");\n                    }\n                });\n                this.selectedTime = -1;\n            }\n        }\n        let selectedItem: Scene | SceneItem = this.scene;\n        if (selectedProperty) {\n            if (document.activeElement) {\n                (document.activeElement as HTMLElement).blur();\n            }\n\n            const selectedIndex = findIndexByProperty(selectedProperty, properties);\n            addClass(properties[selectedIndex].element, \"select\");\n            addClass(values[selectedIndex].element, \"select\");\n            addClass(keyframesList[selectedIndex].element, \"select\");\n\n            selectedItem = (ids.keyframesList[selectedIndex].datas as PropertiesInfo).item;\n            if (keyframeTime >= 0) {\n                const selectedPropertyStructure = ids.keyframesContainers[selectedIndex];\n                const keyframes = selectedPropertyStructure.children as ElementStructure[];\n\n                keyframes.forEach(keyframe => {\n                    if (keyframe.datas.time === keyframeTime) {\n                        addClass(keyframe.element, \"select\");\n                    }\n                });\n                this.selectedTime = keyframeTime;\n            }\n        }\n        this.trigger(\"select\", {\n            selectedItem,\n            selectedProperty: this.selectedProperty,\n            selectedTime: this.selectedTime,\n            prevSelectedProperty,\n            prevSelectedTime,\n        });\n    }\n    private initClickProperty() {\n        const ids = this.ids;\n        const {\n            propertiesAreas,\n        } = ids;\n\n        propertiesAreas[1].element.addEventListener(\"click\", e => {\n            const properties = ids.properties.map(property => property.element);\n            const length = properties.length;\n            const arrow = getTarget(e.target as HTMLElement, el => hasClass(el, \"arrow\"));\n            const remove = getTarget(e.target as HTMLElement, el => hasClass(el, \"remove\"));\n            const target = getTarget(e.target as HTMLElement, el => hasClass(el, \"property\"));\n\n            if (!target) {\n                return;\n            }\n            const index = properties.indexOf(target);\n\n            if (index === -1) {\n                return;\n            }\n            const selectedProperty = ids.properties[index];\n            if (remove) {\n                this.remove(selectedProperty.datas as PropertiesInfo);\n            } else {\n                this.select(selectedProperty.dataset.key);\n\n                if (arrow) {\n                    this.fold(index);\n                }\n            }\n        });\n    }\n    private setInputs(obj: IObject<any>) {\n        const valuesArea = this.ids.valuesArea.element;\n        for (const name in obj) {\n            valuesArea.querySelector<HTMLInputElement>(`[data-key=\"${name}\"] input`).value = obj[name];\n        }\n    }\n    private moveCursor(time: number) {\n        const {cursors} = this.ids;\n        const maxTime = this.maxTime;\n        const px = 15 - 30 * time / maxTime;\n        const percent = 100 * time / maxTime;\n        const left = `calc(${percent}% + ${px}px)`;\n\n        cursors.forEach(cursor => {\n            cursor.element.style.left = left;\n        });\n    }\n    private initDragKeyframes() {\n        const ids = this.ids;\n        const {\n            scrollArea,\n            timeArea,\n            cursors,\n            keyframesAreas,\n            keyframesScrollAreas,\n        } = ids;\n        const scene = this.scene;\n\n        scene.on(\"animate\", e => {\n            const time = e.time;\n            this.moveCursor(time);\n            this.setInputs(flatObject(e.frames || e.frame.get()));\n            const minute = numberFormat(Math.floor(time / 60), 2);\n            const second = numberFormat(Math.floor(time % 60), 2);\n            const milisecond = numberFormat(Math.floor((time % 1) * 100), 3, true);\n            (timeArea.element as HTMLInputElement).value = `${minute}:${second}:${milisecond}`;\n        });\n        const getDistTime = (\n            distX: number,\n            rect: ClientRect = keyframesScrollAreas[1].element.getBoundingClientRect(),\n        ) => {\n            const scrollAreaWidth = rect.width - 30;\n            const percentage = Math.min(scrollAreaWidth, distX) / scrollAreaWidth;\n            const time = this.maxTime * percentage;\n\n            return Math.round(time * 20) / 20;\n        };\n        const getTime = (clientX: number) => {\n            const rect = keyframesScrollAreas[1].element.getBoundingClientRect();\n            const scrollAreaX = rect.left + 15;\n            const x = Math.max(clientX - scrollAreaX, 0);\n\n            return getDistTime(x, rect);\n        };\n        const move = (clientX: number) => {\n            this.setTime(getTime(clientX));\n        };\n        const click = (e, clientX, clientY) => {\n            const target = getTarget(e.target as HTMLElement, el => hasClass(el, \"keyframe\"));\n            const time = target ? parseFloat(target.getAttribute(\"data-time\")) : getTime(clientX);\n\n            this.setTime(time);\n            const list = ids.keyframesList;\n            const index = findElementIndexByPosition(\n                list.map(({element}) => element),\n                clientY,\n            );\n\n            if (index > -1) {\n                this.select(list[index].dataset.key, time);\n            }\n            e.preventDefault();\n        };\n        const dblclick = (e, clientX, clientY) => {\n            const list = ids.keyframesList;\n            const index = findElementIndexByPosition(\n                list.map(({element}) => element),\n                clientY,\n            );\n\n            if (index === -1) {\n                return;\n            }\n            this.addKeyframe(index, getTime(clientX));\n        };\n        drag(cursors[0].element, {\n            dragstart: ({inputEvent}) => {\n                inputEvent.stopPropagation();\n            },\n            drag: ({ clientX }) => {\n                move(clientX);\n            },\n            container: window,\n        });\n\n        let dragItem: Scene | SceneItem = null;\n        let dragDelay: number = 0;\n        let dragTarget: HTMLElement = null;\n\n        keyframesScrollAreas.forEach(({ element }) => {\n            drag(element, {\n                container: window,\n                dragstart: ({ inputEvent }) => {\n                    dragTarget = getTarget(inputEvent.target, el => hasClass(el, \"keyframe_group\"));\n                    if (dragTarget) {\n                        const properties = this.ids.properties;\n                        const keyframesTarget = getTarget(dragTarget, el => hasClass(el, \"keyframes\"));\n                        const key = keyframesTarget.getAttribute(\"data-key\");\n                        const property = findStructureByProperty(key, properties);\n                        const propertiesInfo = property.datas as PropertiesInfo;\n\n                        dragItem = propertiesInfo.item;\n                        dragDelay = dragItem.getDelay();\n                    }\n                },\n                drag: ({ distX, deltaX, deltaY, inputEvent }) => {\n                    if (dragTarget) {\n                        dragItem.setDelay(Math.max(dragDelay + getDistTime(distX), 0));\n                        this.update();\n                    } else {\n                        keyframesAreas[1].element.scrollLeft -= deltaX;\n                        scrollArea.element.scrollTop -= deltaY;\n                        inputEvent.preventDefault();\n                    }\n                },\n                dragend: ({ isDrag, clientX, clientY, inputEvent }) => {\n                    dragTarget = null;\n                    dragItem = null;\n                    dragDelay = null;\n                    !isDrag && click(inputEvent, clientX, clientY);\n                    dblCheck(isDrag, inputEvent, clientX, clientY, dblclick);\n                },\n            });\n        });\n    }\n    private initDragValues() {\n        const ids = this.ids;\n        const element = ids.valuesArea.element;\n        let dragTarget: HTMLInputElement = null;\n        let dragTargetValue: any;\n\n        addEvent(element, \"click\", e => {\n            const addedElement = getTarget(dragTarget, el => hasClass(el, \"add\"));\n            if (!addedElement) {\n                return;\n            }\n            const valueElement = addedElement.parentElement as HTMLElement;\n            const index = findIndexByProperty(valueElement.getAttribute(\"data-key\"), ids.values);\n\n            if (index < 0) {\n                return;\n            }\n\n            const propertiesInfo = ids.properties[index].datas as PropertiesInfo;\n            const properties = propertiesInfo.properties.slice();\n            const item = propertiesInfo.item;\n\n            if (isScene(item)) {\n                this.newItem(item);\n            } else {\n                this.newProperty(item, properties);\n            }\n\n        });\n        drag(element, {\n            container: window,\n            dragstart: e => {\n                dragTarget = e.inputEvent.target;\n                dragTargetValue = dragTarget.value;\n\n                if (!this.keycon.altKey || !getTarget(dragTarget, el => el.nodeName === \"INPUT\")) {\n                    return false;\n                }\n            },\n            drag: e => {\n                const nextValue = dragTargetValue.replace(/-?\\d+/g, num => {\n                    return `${parseFloat(num) + Math.round(e.distX / 2)}`;\n                });\n\n                dragTarget.value = nextValue;\n            },\n            dragend: e => {\n                this.edit(dragTarget, dragTarget.value);\n            },\n        });\n    }\n    private addKeyframe(index: number, time: number) {\n        const list = this.ids.keyframesList;\n        const property = list[index].dataset.key;\n        const {item, properties} = list[index].datas as PropertiesInfo;\n\n        this.select(property, time);\n\n        const value = ((this.ids.values[index].children as ElementStructure).element as HTMLInputElement).value;\n\n        this.editKeyframe(index, value);\n    }\n    private fold(index: number, forceFold?: boolean) {\n        const ids = this.ids;\n        const {properties, values, keyframesList} = ids;\n        const selectedProperty = properties[index];\n        const length = properties.length;\n        let max;\n        for (max = index + 1; max < length; ++max) {\n            if (properties[max].datas.key.indexOf(selectedProperty.datas.key + \"///\") !== 0) {\n                break;\n            }\n        }\n        const foldProperties = properties.slice(index + 1, max);\n        const foldValues = values.slice(index + 1, max);\n        const foldKeyframesList = keyframesList.slice(index + 1, max);\n        const selectedElement = selectedProperty.element;\n        // true : unfold, false: fold\n        const isFold = isUndefined(forceFold) ? selectedElement.getAttribute(\"data-fold\") === \"1\" : forceFold;\n\n        selectedElement.setAttribute(\"data-fold\", isFold ? \"0\" : \"1\");\n        const foldFunction = (isFold ? removeClass : addClass);\n        const depth = selectedProperty.datas.keys.length;\n\n        foldProperties.forEach((property, i) => {\n            const datas = property.datas as PropertiesInfo;\n            if (depth + 1 < datas.keys.length) {\n                return;\n            }\n            foldFunction(property.element, \"fold\");\n            foldFunction(foldValues[i].element, \"fold\");\n            foldFunction(foldKeyframesList[i].element, \"fold\");\n            if (datas.isParent) {\n                if (!isFold) {\n                    this.fold(index + 1 + i, false);\n                } else {\n                    // always fold\n                    property.element.setAttribute(\"data-fold\", \"1\");\n                }\n            } else {\n                property.element.setAttribute(\"data-fold\", isFold ? \"0\" : \"1\");\n            }\n        });\n    }\n    private remove(propertiesInfo: PropertiesInfo) {\n        const {key, isItem, parentItem, item: targetItem, properties} = propertiesInfo;\n        if (isItem) {\n            let targetName: string = null;\n            parentItem.forEach((item, name) => {\n                if (item === targetItem) {\n                    targetName = name;\n                    return;\n                }\n            });\n            if (targetName != null) {\n                parentItem.removeItem(targetName);\n            }\n        } else {\n            const times = (targetItem as SceneItem).times;\n\n            times.forEach(time => {\n                (targetItem as SceneItem).remove(time, ...properties);\n            });\n        }\n        if (this.selectedProperty === key) {\n            this.selectedProperty = \"\";\n            this.selectedTime = -1;\n        }\n        this.update();\n    }\n    private removeKeyframe(property: string) {\n        const propertiesInfo = this.timelineInfo[property];\n        if (!property || !propertiesInfo || isScene(propertiesInfo.item)) {\n            return;\n        }\n\n        const properties = propertiesInfo.properties;\n        const item = propertiesInfo.item;\n\n        item.remove(item.getIterationTime(), ...properties);\n        this.update();\n    }\n    private editKeyframe(index: number, value: any) {\n        const ids = this.ids;\n        const isObjectData = ids.properties[index].dataset.object === \"1\";\n\n        if (isObjectData) {\n            return;\n        }\n        const propertiesInfo = ids.keyframesList[index].datas as PropertiesInfo;\n        const item = propertiesInfo.item;\n        const properties = propertiesInfo.properties;\n\n        item.set(item.getIterationTime(), ...properties, value);\n        this.update();\n    }\n    private restoreKeyframes() {\n        this.setTime(this.scene.getTime());\n    }\n    private edit(target: HTMLInputElement, value: any) {\n        const parentEl = getTarget(target, el => hasClass(el, \"value\"));\n\n        if (!parentEl) {\n            return;\n        }\n        const values = this.ids.values.map(({element}) => element);\n        const index = values.indexOf(parentEl);\n\n        if (index === -1) {\n            return;\n        }\n        this.editKeyframe(index, value);\n    }\n    private initEditor() {\n        const valuesArea = this.ids.valuesArea.element;\n\n        new KeyController(valuesArea)\n        .keydown(e => {\n            !e.isToggle && e.inputEvent.stopPropagation();\n        })\n        .keyup(e => {\n            !e.isToggle && e.inputEvent.stopPropagation();\n        })\n        .keyup(\"enter\", e => {\n            const target = e.inputEvent.target as HTMLInputElement;\n\n            this.edit(target, target.value);\n        })\n        .keyup(\"esc\", e => {\n            const target = e.inputEvent.target as HTMLInputElement;\n\n            target.blur();\n        });\n        valuesArea.addEventListener(\"focusout\", e => {\n            this.restoreKeyframes();\n        });\n    }\n}\n","import { Ids, ElementStructure } from \"./types\";\n\nexport function getControlAreaStructure(ids: Ids): ElementStructure {\n    return {\n        selector: \".header_area.control_area\",\n        children: [\n            {\n                selector: \".properties_area\",\n                ref: (e: ElementStructure) => {\n                    ids.unselectedArea = e;\n                },\n                children: {\n                    selector: \".property\",\n                },\n            },\n            {\n                selector: \".values_area\",\n                children: {\n                    selector: \".value\",\n                },\n            },\n            {\n                selector: \".keyframes_area\",\n                children: {\n                    selector: \".keyframes\",\n                    children: [\n                        {\n                            selector: \"input.time_area\",\n                            ref: (e: ElementStructure) => {\n                                ids.timeArea = e;\n                            },\n                            html: \"???\",\n                            // html: \"0\",\n                        },\n                        {\n                            selector: \".play_control_area\",\n                            children: [\n                                {\n                                    ref: (e: ElementStructure) => {\n                                        ids.prevBtn = e;\n                                    },\n                                    selector: \".control.prev\",\n                                },\n                                {\n                                    ref: (e: ElementStructure) => {\n                                        ids.playBtn = e;\n                                    },\n                                    selector: \".control.play\",\n                                },\n                                {\n                                    ref: (e: ElementStructure) => {\n                                        ids.nextBtn = e;\n                                    },\n                                    selector: \".control.next\",\n                                },\n                            ],\n                        },\n                    ],\n                },\n            },\n        ],\n    };\n}\n"],"names":["PREFIX","SUPPORT_POINTER_EVENTS","window","SUPPORT_TOUCH","CSS","replace","DIRECTION","ITERATION_COUNT","DELAY","PLAY_SPEED","ALTERNATE","REVERSE","ALTERNATE_REVERSE","numberFormat","num","count","isRight","length","arr","push","i","join","applyStyle","el","style","name","findIndex","callback","findIndexByProperty","selectedProperty","structures","_a","findStructureByProperty","find","createElement","structure","selector","dataset","attr","html","classNames","match","tag","id","document","className","map","setAttribute","innerHTML","updateElement","prevStructure","nextStructure","element","toValue","value","Array","isArray","keys","k","getTarget","target","conditionCallback","parentTarget","body","parentNode","hasClass","hasClass2","addClass","addClass2","removeClass","removeClass2","isScene","constructor","prototype","getItem","findElementIndexByPosition","elements","pos","index","box","getBoundingClientRect","top","bottom","height","prevTime","prevX","prevY","getKeytimesAreaStructure","ids","zoom","maxDuration","maxTime","ref","e","keyframesAreas","children","minWidth","width","Math","min","keyframesScrollAreas","cursors","keytimesContainer","keytimes","time","key","getKeytimesStructure","getKeyframesAreaStructure","keyframesList","lineArea","lines","left","getLinesStructure","getKeyframesScrollAreaChildrenStructure","getKeyframesStructure","propertiesInfo","item","frames","properties","isItScene","duration","getDuration","keyframes","keyframeGroups","delayFrames","keyframeLines","hasProperties","startIndex","isUndefined","max","startFrame","endFrame","nextTime","datas","from","to","forEach","iterationTime","valueText","_b","nextIterationTime","getDelayFrameStructure","_c","nextValue","nextValueText","getScrollAreaStructure","timelineInfo","keyframesContainers","isItem","getKeyframesListStructure","scrollArea","propertiesAreas","propertyNames","object","isParent","paddingLeft","getPropertiesStructure","valuesArea","values","getValuesStructure","MAXIMUM","toFixed","round","addEntry","entries","keytime","prevEntry","getEntries","times","states","nextEntries","unshift","state","b1","b2","iterationCount","delay","playSpeed","direction","intCount","ceil","currentDuration","lastTime","isReverse","j","entry","currentTime","divideTime","getTimelineInfo","scene","sceneForEach","_i","items","lastItem","names","slice","getId","animator","reverse","frames_1","parentItem","update","originalDuration","getFrame","getPropertyInfo","itemNames","isObject","get","property","getItemInfo","isExportCSS","parentEl","options","_super","_this","keyboard","finish","initStructure","initEditor","initScroll","initWheelZoom","initDragKeyframes","initClickProperty","initController","initDragValues","initKeyController","setTime","tslib_1","this","getTime","getPlayState","pause","play","getDirection","axes","currentMaxTime","prevKeytimesArea","nextZoom","axm","set","datadom","nextScrollAreaStructure","prompt","newItem","getIterationTime","playBtn","addItem","addEventListener","newProperty","togglePlay","preventDefault","unselectedArea","select","prevBtn","prev","nextBtn","next","on","KeyController","timeArea","keydown","isToggle","inputEvent","stopPropagation","keyup","result","exec","parseFloat","timeline","keycon","removeKeyframe","timelineCSS","getControlAreaStructure","getHeaderAreaStructure","DataDOM","render","fold","isScrollKeyframe","headerKeyframesArea","scrollKeyframesArea","scrollLeft","headerArea","Axes","range","Infinity","connect","PinchInput","scale","hammerManagerOptions","touchAction","delta","deltaY","setBy","deltaX","addEvent","altKey","keyframeTime","prevSelectedProperty","prevSelectedTime","selectedTime","prevSelectedIndex","keyframe","selectedItem","activeElement","blur","selectedIndex","trigger","arrow","remove","indexOf","obj","querySelector","cursor","moveCursor","setInputs","flatObject","newObj","nextObj","toCSS","nextName","frame","minute","floor","second","milisecond","getDistTime","distX","rect","scrollAreaWidth","percentage","clientX","scrollAreaX","x","dblclick","clientY","addKeyframe","drag","dragstart","move","container","dragItem","dragDelay","dragTarget","getAttribute","getDelay","setDelay","scrollTop","dragend","isDrag","list","click","now","dblCheck","dragTargetValue","addedElement","parentElement","nodeName","edit","editKeyframe","forceFold","foldProperties","foldValues","foldKeyframesList","selectedElement","isFold","foldFunction","depth","targetItem","targetName_1","removeItem","restoreKeyframes","Component"],"mappings":"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"}